{"ast":null,"code":"function _typeof2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*!\n * dist/inputmask\n * https://github.com/RobinHerbots/Inputmask\n * Copyright (c) 2010 - 2020 Robin Herbots\n * Licensed under the MIT license\n * Version: 5.0.5-beta.0\n */\n!function webpackUniversalModuleDefinition(root, factory) {\n  if (\"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof2(exports)) && \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof2(module))) module.exports = factory();else if (\"function\" == typeof define && define.amd) define([], factory);else {\n    var a = factory();\n\n    for (var i in a) {\n      (\"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof2(exports)) ? exports : root)[i] = a[i];\n    }\n  }\n}(window, function () {\n  return modules = [function (module) {\n    module.exports = JSON.parse('{\"BACKSPACE\":8,\"BACKSPACE_SAFARI\":127,\"DELETE\":46,\"DOWN\":40,\"END\":35,\"ENTER\":13,\"ESCAPE\":27,\"HOME\":36,\"INSERT\":45,\"LEFT\":37,\"PAGE_DOWN\":34,\"PAGE_UP\":33,\"RIGHT\":39,\"SPACE\":32,\"TAB\":9,\"UP\":38,\"X\":88,\"CONTROL\":17,\"KEY_229\":229}');\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = void 0, __webpack_require__(10);\n\n    var _mask = __webpack_require__(11),\n        _inputmask = _interopRequireDefault(__webpack_require__(9)),\n        _window = _interopRequireDefault(__webpack_require__(6)),\n        _maskLexer = __webpack_require__(19),\n        _validationTests = __webpack_require__(3),\n        _positioning = __webpack_require__(2),\n        _validation = __webpack_require__(4),\n        _inputHandling = __webpack_require__(5),\n        _eventruler = __webpack_require__(12),\n        _definitions = _interopRequireDefault(__webpack_require__(20)),\n        _defaults = _interopRequireDefault(__webpack_require__(21));\n\n    function _typeof(obj) {\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == _typeof2(Symbol.iterator) ? function _typeof(obj) {\n        return _typeof2(obj);\n      } : function _typeof(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      }, _typeof(obj);\n    }\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var document = _window[\"default\"].document,\n        dataKey = \"_inputmask_opts\";\n\n    function Inputmask(alias, options, internal) {\n      if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);\n      this.dependencyLib = _inputmask[\"default\"], this.el = void 0, this.events = {}, this.maskset = void 0, !0 !== internal && (\"[object Object]\" === Object.prototype.toString.call(alias) ? options = alias : (options = options || {}, alias && (options.alias = alias)), this.opts = _inputmask[\"default\"].extend(!0, {}, this.defaults, options), this.noMasksCache = options && void 0 !== options.definitions, this.userOptions = options || {}, resolveAlias(this.opts.alias, options, this.opts)), this.refreshValue = !1, this.undoValue = void 0, this.$el = void 0, this.skipKeyPressEvent = !1, this.skipInputEvent = !1, this.validationEvent = !1, this.ignorable = !1, this.maxLength, this.mouseEnter = !1, this.originalPlaceholder = void 0, this.isComposing = !1;\n    }\n\n    function resolveAlias(aliasStr, options, opts) {\n      var aliasDefinition = Inputmask.prototype.aliases[aliasStr];\n      return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts), _inputmask[\"default\"].extend(!0, opts, aliasDefinition), _inputmask[\"default\"].extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), !1);\n    }\n\n    function importAttributeOptions(npt, opts, userOptions, dataAttribute) {\n      function importOption(option, optionData) {\n        var attrOption = \"\" === dataAttribute ? option : dataAttribute + \"-\" + option;\n        optionData = void 0 !== optionData ? optionData : npt.getAttribute(attrOption), null !== optionData && (\"string\" == typeof optionData && (0 === option.indexOf(\"on\") ? optionData = _window[\"default\"][optionData] : \"false\" === optionData ? optionData = !1 : \"true\" === optionData && (optionData = !0)), userOptions[option] = optionData);\n      }\n\n      if (!0 === opts.importDataAttributes) {\n        var attrOptions = npt.getAttribute(dataAttribute),\n            option,\n            dataoptions,\n            optionData,\n            p;\n        if (attrOptions && \"\" !== attrOptions && (attrOptions = attrOptions.replace(/'/g, '\"'), dataoptions = JSON.parse(\"{\" + attrOptions + \"}\")), dataoptions) for (p in optionData = void 0, dataoptions) {\n          if (\"alias\" === p.toLowerCase()) {\n            optionData = dataoptions[p];\n            break;\n          }\n        }\n\n        for (option in importOption(\"alias\", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts), opts) {\n          if (dataoptions) for (p in optionData = void 0, dataoptions) {\n            if (p.toLowerCase() === option.toLowerCase()) {\n              optionData = dataoptions[p];\n              break;\n            }\n          }\n          importOption(option, optionData);\n        }\n      }\n\n      return _inputmask[\"default\"].extend(!0, opts, userOptions), \"rtl\" !== npt.dir && !opts.rightAlign || (npt.style.textAlign = \"right\"), \"rtl\" !== npt.dir && !opts.numericInput || (npt.dir = \"ltr\", npt.removeAttribute(\"dir\"), opts.isRTL = !0), Object.keys(userOptions).length;\n    }\n\n    Inputmask.prototype = {\n      dataAttribute: \"data-inputmask\",\n      defaults: _defaults[\"default\"],\n      definitions: _definitions[\"default\"],\n      aliases: {},\n      masksCache: {},\n\n      get isRTL() {\n        return this.opts.isRTL || this.opts.numericInput;\n      },\n\n      mask: function mask(elems) {\n        var that = this;\n        return \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, elems.forEach(function (el, ndx) {\n          var scopedOpts = _inputmask[\"default\"].extend(!0, {}, that.opts);\n\n          if (importAttributeOptions(el, scopedOpts, _inputmask[\"default\"].extend(!0, {}, that.userOptions), that.dataAttribute)) {\n            var maskset = (0, _maskLexer.generateMaskSet)(scopedOpts, that.noMasksCache);\n            void 0 !== maskset && (void 0 !== el.inputmask && (el.inputmask.opts.autoUnmask = !0, el.inputmask.remove()), el.inputmask = new Inputmask(void 0, void 0, !0), el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = _inputmask[\"default\"].extend(!0, {}, that.userOptions), el.inputmask.el = el, el.inputmask.$el = (0, _inputmask[\"default\"])(el), el.inputmask.maskset = maskset, _inputmask[\"default\"].data(el, dataKey, that.userOptions), _mask.mask.call(el.inputmask));\n          }\n        }), elems && elems[0] && elems[0].inputmask || this;\n      },\n      option: function option(options, noremask) {\n        return \"string\" == typeof options ? this.opts[options] : \"object\" === _typeof(options) ? (_inputmask[\"default\"].extend(this.userOptions, options), this.el && !0 !== noremask && this.mask(this.el), this) : void 0;\n      },\n      unmaskedvalue: function unmaskedvalue(value) {\n        if (this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), void 0 === this.el || void 0 !== value) {\n          var valueBuffer = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, value, this.opts) || value).split(\"\");\n          _inputHandling.checkVal.call(this, void 0, !1, !1, valueBuffer), \"function\" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, _positioning.getBuffer.call(this), 0, this.opts);\n        }\n\n        return _inputHandling.unmaskedvalue.call(this, this.el);\n      },\n      remove: function remove() {\n        if (this.el) {\n          _inputmask[\"default\"].data(this.el, dataKey, null);\n\n          var cv = this.opts.autoUnmask ? (0, _inputHandling.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask),\n              valueProperty;\n          cv !== _positioning.getBufferTemplate.call(this).join(\"\") ? this._valueSet(cv, this.opts.autoUnmask) : this._valueSet(\"\"), _eventruler.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? (valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), \"value\"), valueProperty && this.__valueGet && Object.defineProperty(this.el, \"value\", {\n            get: this.__valueGet,\n            set: this.__valueSet,\n            configurable: !0\n          })) : document.__lookupGetter__ && this.el.__lookupGetter__(\"value\") && this.__valueGet && (this.el.__defineGetter__(\"value\", this.__valueGet), this.el.__defineSetter__(\"value\", this.__valueSet)), this.el.inputmask = void 0;\n        }\n\n        return this.el;\n      },\n      getemptymask: function getemptymask() {\n        return this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), _positioning.getBufferTemplate.call(this).join(\"\");\n      },\n      hasMaskedValue: function hasMaskedValue() {\n        return !this.opts.autoUnmask;\n      },\n      isComplete: function isComplete() {\n        return this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), _validation.isComplete.call(this, _positioning.getBuffer.call(this));\n      },\n      getmetadata: function getmetadata() {\n        if (this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), Array.isArray(this.maskset.metadata)) {\n          var maskTarget = _validationTests.getMaskTemplate.call(this, !0, 0, !1).join(\"\");\n\n          return this.maskset.metadata.forEach(function (mtdt) {\n            return mtdt.mask !== maskTarget || (maskTarget = mtdt, !1);\n          }), maskTarget;\n        }\n\n        return this.maskset.metadata;\n      },\n      isValid: function isValid(value) {\n        if (this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache), value) {\n          var valueBuffer = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, value, this.opts) || value).split(\"\");\n\n          _inputHandling.checkVal.call(this, void 0, !0, !1, valueBuffer);\n        } else value = this.isRTL ? _positioning.getBuffer.call(this).slice().reverse().join(\"\") : _positioning.getBuffer.call(this).join(\"\");\n\n        for (var buffer = _positioning.getBuffer.call(this), rl = _positioning.determineLastRequiredPosition.call(this), lmib = buffer.length - 1; rl < lmib && !_positioning.isMask.call(this, lmib); lmib--) {\n          ;\n        }\n\n        return buffer.splice(rl, lmib + 1 - rl), _validation.isComplete.call(this, buffer) && value === (this.isRTL ? _positioning.getBuffer.call(this).slice().reverse().join(\"\") : _positioning.getBuffer.call(this).join(\"\"));\n      },\n      format: function format(value, metadata) {\n        this.maskset = this.maskset || (0, _maskLexer.generateMaskSet)(this.opts, this.noMasksCache);\n        var valueBuffer = (\"function\" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, value, this.opts) || value).split(\"\");\n\n        _inputHandling.checkVal.call(this, void 0, !0, !1, valueBuffer);\n\n        var formattedValue = this.isRTL ? _positioning.getBuffer.call(this).slice().reverse().join(\"\") : _positioning.getBuffer.call(this).join(\"\");\n        return metadata ? {\n          value: formattedValue,\n          metadata: this.getmetadata()\n        } : formattedValue;\n      },\n      setValue: function setValue(value) {\n        this.el && (0, _inputmask[\"default\"])(this.el).trigger(\"setvalue\", [value]);\n      },\n      analyseMask: _maskLexer.analyseMask\n    }, Inputmask.extendDefaults = function (options) {\n      _inputmask[\"default\"].extend(!0, Inputmask.prototype.defaults, options);\n    }, Inputmask.extendDefinitions = function (definition) {\n      _inputmask[\"default\"].extend(!0, Inputmask.prototype.definitions, definition);\n    }, Inputmask.extendAliases = function (alias) {\n      _inputmask[\"default\"].extend(!0, Inputmask.prototype.aliases, alias);\n    }, Inputmask.format = function (value, options, metadata) {\n      return Inputmask(options).format(value, metadata);\n    }, Inputmask.unmask = function (value, options) {\n      return Inputmask(options).unmaskedvalue(value);\n    }, Inputmask.isValid = function (value, options) {\n      return Inputmask(options).isValid(value);\n    }, Inputmask.remove = function (elems) {\n      \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, elems.forEach(function (el) {\n        el.inputmask && el.inputmask.remove();\n      });\n    }, Inputmask.setValue = function (elems, value) {\n      \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), elems = elems.nodeName ? [elems] : elems, elems.forEach(function (el) {\n        el.inputmask ? el.inputmask.setValue(value) : (0, _inputmask[\"default\"])(el).trigger(\"setvalue\", [value]);\n      });\n    }, Inputmask.dependencyLib = _inputmask[\"default\"], _window[\"default\"].Inputmask = Inputmask;\n    var _default = Inputmask;\n    exports[\"default\"] = _default;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.caret = caret, exports.determineLastRequiredPosition = determineLastRequiredPosition, exports.determineNewCaretPosition = determineNewCaretPosition, exports.getBuffer = getBuffer, exports.getBufferTemplate = getBufferTemplate, exports.getLastValidPosition = getLastValidPosition, exports.isMask = isMask, exports.resetMaskSet = resetMaskSet, exports.seekNext = seekNext, exports.seekPrevious = seekPrevious, exports.translatePosition = translatePosition;\n\n    var _validationTests = __webpack_require__(3),\n        _validation = __webpack_require__(4),\n        _mask = __webpack_require__(11);\n\n    function caret(input, begin, end, notranslate, isDelete) {\n      var inputmask = this,\n          opts = this.opts,\n          range;\n      if (void 0 === begin) return \"selectionStart\" in input && \"selectionEnd\" in input ? (begin = input.selectionStart, end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0), range.commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(), begin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length), end = begin + range.text.length), {\n        begin: notranslate ? begin : translatePosition.call(this, begin),\n        end: notranslate ? end : translatePosition.call(this, end)\n      };\n\n      if (Array.isArray(begin) && (end = this.isRTL ? begin[0] : begin[1], begin = this.isRTL ? begin[1] : begin[0]), void 0 !== begin.begin && (end = this.isRTL ? begin.begin : begin.end, begin = this.isRTL ? begin.end : begin.begin), \"number\" == typeof begin) {\n        begin = notranslate ? begin : translatePosition.call(this, begin), end = notranslate ? end : translatePosition.call(this, end), end = \"number\" == typeof end ? end : begin;\n        var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\n        if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, input.inputmask.caretPos = {\n          begin: begin,\n          end: end\n        }, opts.insertModeVisual && !1 === opts.insertMode && begin === end && (isDelete || end++), input === (input.inputmask.shadowRoot || document).activeElement) if (\"setSelectionRange\" in input) input.setSelectionRange(begin, end);else if (window.getSelection) {\n          if (range = document.createRange(), void 0 === input.firstChild || null === input.firstChild) {\n            var textNode = document.createTextNode(\"\");\n            input.appendChild(textNode);\n          }\n\n          range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), range.collapse(!0);\n          var sel = window.getSelection();\n          sel.removeAllRanges(), sel.addRange(range);\n        } else input.createTextRange && (range = input.createTextRange(), range.collapse(!0), range.moveEnd(\"character\", end), range.moveStart(\"character\", begin), range.select());\n      }\n    }\n\n    function determineLastRequiredPosition(returnDefinition) {\n      var inputmask = this,\n          maskset = this.maskset,\n          $ = this.dependencyLib,\n          buffer = _validationTests.getMaskTemplate.call(this, !0, getLastValidPosition.call(this), !0, !0),\n          bl = buffer.length,\n          pos,\n          lvp = getLastValidPosition.call(this),\n          positions = {},\n          lvTest = maskset.validPositions[lvp],\n          ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0,\n          testPos;\n\n      for (pos = lvp + 1; pos < buffer.length; pos++) {\n        testPos = _validationTests.getTestTemplate.call(this, pos, ndxIntlzr, pos - 1), ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);\n      }\n\n      var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;\n\n      for (pos = bl - 1; lvp < pos && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && 1 != testPos.match[\"static\"] || !0 === testPos.match[\"static\"] && testPos.locator[lvTest.alternation] && _validation.checkAlternationMatch.call(this, testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) && \"\" !== _validationTests.getTests.call(this, pos)[0].def)) && buffer[pos] === _validationTests.getPlaceholder.call(this, pos, testPos.match)); pos--) {\n        bl--;\n      }\n\n      return returnDefinition ? {\n        l: bl,\n        def: positions[bl] ? positions[bl].match : void 0\n      } : bl;\n    }\n\n    function determineNewCaretPosition(selectedCaret, tabbed) {\n      var inputmask = this,\n          maskset = this.maskset,\n          opts = this.opts;\n\n      function doRadixFocus(clickPos) {\n        if (\"\" !== opts.radixPoint && 0 !== opts.digits) {\n          var vps = maskset.validPositions;\n\n          if (void 0 === vps[clickPos] || vps[clickPos].input === _validationTests.getPlaceholder.call(inputmask, clickPos)) {\n            if (clickPos < seekNext.call(inputmask, -1)) return !0;\n            var radixPos = getBuffer.call(inputmask).indexOf(opts.radixPoint);\n\n            if (-1 !== radixPos) {\n              for (var vp in vps) {\n                if (vps[vp] && radixPos < vp && vps[vp].input !== _validationTests.getPlaceholder.call(inputmask, vp)) return !1;\n              }\n\n              return !0;\n            }\n          }\n        }\n\n        return !1;\n      }\n\n      if (tabbed && (inputmask.isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end), selectedCaret.begin === selectedCaret.end) {\n        switch (opts.positionCaretOnClick) {\n          case \"none\":\n            break;\n\n          case \"select\":\n            selectedCaret = {\n              begin: 0,\n              end: getBuffer.call(inputmask).length\n            };\n            break;\n\n          case \"ignore\":\n            selectedCaret.end = selectedCaret.begin = seekNext.call(inputmask, getLastValidPosition.call(inputmask));\n            break;\n\n          case \"radixFocus\":\n            if (doRadixFocus(selectedCaret.begin)) {\n              var radixPos = getBuffer.call(inputmask).join(\"\").indexOf(opts.radixPoint);\n              selectedCaret.end = selectedCaret.begin = opts.numericInput ? seekNext.call(inputmask, radixPos) : radixPos;\n              break;\n            }\n\n          default:\n            var clickPosition = selectedCaret.begin,\n                lvclickPosition = getLastValidPosition.call(inputmask, clickPosition, !0),\n                lastPosition = seekNext.call(inputmask, -1 !== lvclickPosition || isMask.call(inputmask, 0) ? lvclickPosition : -1);\n            if (clickPosition <= lastPosition) selectedCaret.end = selectedCaret.begin = isMask.call(inputmask, clickPosition, !1, !0) ? clickPosition : seekNext.call(inputmask, clickPosition);else {\n              var lvp = maskset.validPositions[lvclickPosition],\n                  tt = _validationTests.getTestTemplate.call(inputmask, lastPosition, lvp ? lvp.match.locator : void 0, lvp),\n                  placeholder = _validationTests.getPlaceholder.call(inputmask, lastPosition, tt.match);\n\n              if (\"\" !== placeholder && getBuffer.call(inputmask)[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask.call(inputmask, lastPosition, opts.keepStatic, !0) && tt.match.def === placeholder) {\n                var newPos = seekNext.call(inputmask, lastPosition);\n                (newPos <= clickPosition || clickPosition === lastPosition) && (lastPosition = newPos);\n              }\n\n              selectedCaret.end = selectedCaret.begin = lastPosition;\n            }\n        }\n\n        return selectedCaret;\n      }\n    }\n\n    function getBuffer(noCache) {\n      var inputmask = this,\n          maskset = this.maskset;\n      return void 0 !== maskset.buffer && !0 !== noCache || (maskset.buffer = _validationTests.getMaskTemplate.call(this, !0, getLastValidPosition.call(this), !0), void 0 === maskset._buffer && (maskset._buffer = maskset.buffer.slice())), maskset.buffer;\n    }\n\n    function getBufferTemplate() {\n      var inputmask = this,\n          maskset = this.maskset;\n      return void 0 === maskset._buffer && (maskset._buffer = _validationTests.getMaskTemplate.call(this, !1, 1), void 0 === maskset.buffer && (maskset.buffer = maskset._buffer.slice())), maskset._buffer;\n    }\n\n    function getLastValidPosition(closestTo, strict, validPositions) {\n      var maskset = this.maskset,\n          before = -1,\n          after = -1,\n          valids = validPositions || maskset.validPositions;\n\n      for (var posNdx in void 0 === closestTo && (closestTo = -1), valids) {\n        var psNdx = parseInt(posNdx);\n        valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx), closestTo <= psNdx && (after = psNdx));\n      }\n\n      return -1 === before || before == closestTo ? after : -1 == after ? before : closestTo - before < after - closestTo ? before : after;\n    }\n\n    function isMask(pos, strict, fuzzy) {\n      var inputmask = this,\n          maskset = this.maskset,\n          test = _validationTests.getTestTemplate.call(this, pos).match;\n\n      if (\"\" === test.def && (test = _validationTests.getTest.call(this, pos).match), !0 !== test[\"static\"]) return test.fn;\n      if (!0 === fuzzy && void 0 !== maskset.validPositions[pos] && !0 !== maskset.validPositions[pos].generatedInput) return !0;\n\n      if (!0 !== strict && -1 < pos) {\n        if (fuzzy) {\n          var tests = _validationTests.getTests.call(this, pos);\n\n          return tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0);\n        }\n\n        var testTemplate = _validationTests.determineTestTemplate.call(this, pos, _validationTests.getTests.call(this, pos)),\n            testPlaceHolder = _validationTests.getPlaceholder.call(this, pos, testTemplate.match);\n\n        return testTemplate.match.def !== testPlaceHolder;\n      }\n\n      return !1;\n    }\n\n    function resetMaskSet(soft) {\n      var maskset = this.maskset;\n      maskset.buffer = void 0, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0);\n    }\n\n    function seekNext(pos, newBlock, fuzzy) {\n      var inputmask = this;\n      void 0 === fuzzy && (fuzzy = !0);\n\n      for (var position = pos + 1; \"\" !== _validationTests.getTest.call(this, position).match.def && (!0 === newBlock && (!0 !== _validationTests.getTest.call(this, position).match.newBlockMarker || !isMask.call(this, position, void 0, !0)) || !0 !== newBlock && !isMask.call(this, position, void 0, fuzzy));) {\n        position++;\n      }\n\n      return position;\n    }\n\n    function seekPrevious(pos, newBlock) {\n      var inputmask = this,\n          position = pos - 1;\n      if (pos <= 0) return 0;\n\n      for (; 0 < position && (!0 === newBlock && (!0 !== _validationTests.getTest.call(this, position).match.newBlockMarker || !isMask.call(this, position, void 0, !0)) || !0 !== newBlock && !isMask.call(this, position, void 0, !0));) {\n        position--;\n      }\n\n      return position;\n    }\n\n    function translatePosition(pos) {\n      var inputmask = this,\n          opts = this.opts,\n          el = this.el;\n      return !this.isRTL || \"number\" != typeof pos || opts.greedy && \"\" === opts.placeholder || !el || (pos = this._valueGet().length - pos), pos;\n    }\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function getLocator(tst, align) {\n      var locator = (null != tst.alternation ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\n      if (\"\" !== locator) for (; locator.length < align;) {\n        locator += \"0\";\n      }\n      return locator;\n    }\n\n    function getDecisionTaker(tst) {\n      var decisionTaker = tst.locator[tst.alternation];\n      return \"string\" == typeof decisionTaker && 0 < decisionTaker.length && (decisionTaker = decisionTaker.split(\",\")[0]), void 0 !== decisionTaker ? decisionTaker.toString() : \"\";\n    }\n\n    function getPlaceholder(pos, test, returnPL) {\n      var inputmask = this,\n          opts = this.opts,\n          maskset = this.maskset;\n      if (test = test || getTest.call(this, pos).match, void 0 !== test.placeholder || !0 === returnPL) return \"function\" == typeof test.placeholder ? test.placeholder(opts) : test.placeholder;\n      if (!0 !== test[\"static\"]) return opts.placeholder.charAt(pos % opts.placeholder.length);\n\n      if (-1 < pos && void 0 === maskset.validPositions[pos]) {\n        var tests = getTests.call(this, pos),\n            staticAlternations = [],\n            prevTest;\n        if (tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) {\n          if (\"\" !== tests[i].match.def && !0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (!0 === tests[i].match[\"static\"] || void 0 === prevTest || !1 !== tests[i].match.fn.test(prevTest.match.def, maskset, pos, !0, opts)) && (staticAlternations.push(tests[i]), !0 === tests[i].match[\"static\"] && (prevTest = tests[i]), 1 < staticAlternations.length && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);\n        }\n      }\n\n      return test.def;\n    }\n\n    function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\n      var inputmask = this,\n          opts = this.opts,\n          maskset = this.maskset,\n          greedy = opts.greedy;\n      clearOptionalTail && (opts.greedy = !1), minimalPos = minimalPos || 0;\n      var maskTemplate = [],\n          ndxIntlzr,\n          pos = 0,\n          test,\n          testPos,\n          jitRenderStatic;\n\n      do {\n        if (!0 === baseOnInput && maskset.validPositions[pos]) testPos = clearOptionalTail && !0 === maskset.validPositions[pos].match.optionality && void 0 === maskset.validPositions[pos + 1] && (!0 === maskset.validPositions[pos].generatedInput || maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && 0 < pos) ? determineTestTemplate.call(this, pos, getTests.call(this, pos, ndxIntlzr, pos - 1)) : maskset.validPositions[pos], test = testPos.match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder.call(this, pos, test));else {\n          testPos = getTestTemplate.call(this, pos, ndxIntlzr, pos - 1), test = testPos.match, ndxIntlzr = testPos.locator.slice();\n          var jitMasking = !0 !== noJit && (!1 !== opts.jitMasking ? opts.jitMasking : test.jit);\n          jitRenderStatic = jitRenderStatic && test[\"static\"] && test.def !== opts.groupSeparator && null === test.fn || maskset.validPositions[pos - 1] && test[\"static\"] && test.def !== opts.groupSeparator && null === test.fn, jitRenderStatic || !1 === jitMasking || void 0 === jitMasking || \"number\" == typeof jitMasking && isFinite(jitMasking) && pos < jitMasking ? maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder.call(this, pos, test)) : jitRenderStatic = !1;\n        }\n        pos++;\n      } while ((void 0 === this.maxLength || pos < this.maxLength) && (!0 !== test[\"static\"] || \"\" !== test.def) || pos < minimalPos);\n\n      return \"\" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), !1 === includeMode && void 0 !== maskset.maskLength || (maskset.maskLength = pos - 1), opts.greedy = greedy, maskTemplate;\n    }\n\n    function getTestTemplate(pos, ndxIntlzr, tstPs) {\n      var inputmask = this,\n          maskset = this.maskset;\n      return maskset.validPositions[pos] || determineTestTemplate.call(this, pos, getTests.call(this, pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\n    }\n\n    function determineTestTemplate(pos, tests) {\n      var inputmask = this,\n          opts = this.opts;\n      pos = 0 < pos ? pos - 1 : 0;\n\n      for (var altTest = getTest.call(this, pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch, ndx = 0; ndx < tests.length; ndx++) {\n        var tst = tests[ndx];\n        tstLocator = getLocator(tst, targetLocator.length);\n        var distance = Math.abs(tstLocator - targetLocator);\n        (void 0 === closest || \"\" !== tstLocator && distance < closest || bestMatch && !opts.greedy && bestMatch.match.optionality && \"master\" === bestMatch.match.newBlockMarker && (!tst.match.optionality || !tst.match.newBlockMarker) || bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier) && (closest = distance, bestMatch = tst);\n      }\n\n      return bestMatch;\n    }\n\n    function getTest(pos, tests) {\n      var inputmask = this,\n          maskset = this.maskset;\n      return maskset.validPositions[pos] ? maskset.validPositions[pos] : (tests || getTests.call(this, pos))[0];\n    }\n\n    function getTests(pos, ndxIntlzr, tstPs) {\n      var inputmask = this,\n          $ = this.dependencyLib,\n          maskset = this.maskset,\n          opts = this.opts,\n          el = this.el,\n          maskTokens = maskset.maskToken,\n          testPos = ndxIntlzr ? tstPs : 0,\n          ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],\n          matches = [],\n          insertStop = !1,\n          latestMatch,\n          cacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\n\n      function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {\n        function handleMatch(match, loopNdx, quantifierRecurse) {\n          function isFirstMatch(latestMatch, tokenGroup) {\n            var firstMatch = 0 === tokenGroup.matches.indexOf(latestMatch);\n            return firstMatch || tokenGroup.matches.every(function (match, ndx) {\n              return !0 === match.isQuantifier ? firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]) : Object.prototype.hasOwnProperty.call(match, \"matches\") && (firstMatch = isFirstMatch(latestMatch, match)), !firstMatch;\n            }), firstMatch;\n          }\n\n          function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\n            var bestMatch, indexPos;\n\n            if ((maskset.tests[pos] || maskset.validPositions[pos]) && (maskset.tests[pos] || [maskset.validPositions[pos]]).every(function (lmnt, ndx) {\n              if (lmnt.mloc[alternateNdx]) return bestMatch = lmnt, !1;\n              var alternation = void 0 !== targetAlternation ? targetAlternation : lmnt.alternation,\n                  ndxPos = void 0 !== lmnt.locator[alternation] ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\n              return (void 0 === indexPos || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt, indexPos = ndxPos), !0;\n            }), bestMatch) {\n              var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation],\n                  locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\n              return locator.slice((void 0 !== targetAlternation ? targetAlternation : bestMatch.alternation) + 1);\n            }\n\n            return void 0 !== targetAlternation ? resolveNdxInitializer(pos, alternateNdx) : void 0;\n          }\n\n          function isSubsetOf(source, target) {\n            function expand(pattern) {\n              for (var expanded = [], start = -1, end, i = 0, l = pattern.length; i < l; i++) {\n                if (\"-\" === pattern.charAt(i)) for (end = pattern.charCodeAt(i + 1); ++start < end;) {\n                  expanded.push(String.fromCharCode(start));\n                } else start = pattern.charCodeAt(i), expanded.push(pattern.charAt(i));\n              }\n\n              return expanded.join(\"\");\n            }\n\n            return source.match.def === target.match.nativeDef || !(!(opts.regex || source.match.fn instanceof RegExp && target.match.fn instanceof RegExp) || !0 === source.match[\"static\"] || !0 === target.match[\"static\"]) && -1 !== expand(target.match.fn.toString().replace(/[[\\]/]/g, \"\")).indexOf(expand(source.match.fn.toString().replace(/[[\\]/]/g, \"\")));\n          }\n\n          function staticCanMatchDefinition(source, target) {\n            return !0 === source.match[\"static\"] && !0 !== target.match[\"static\"] && target.match.fn.test(source.match.def, maskset, pos, !1, opts, !1);\n          }\n\n          function setMergeLocators(targetMatch, altMatch) {\n            var alternationNdx = targetMatch.alternation,\n                shouldMerge = void 0 === altMatch || alternationNdx === altMatch.alternation && -1 === targetMatch.locator[alternationNdx].toString().indexOf(altMatch.locator[alternationNdx]);\n            if (!shouldMerge && alternationNdx > altMatch.alternation) for (var i = altMatch.alternation; i < alternationNdx; i++) {\n              if (targetMatch.locator[i] !== altMatch.locator[i]) {\n                alternationNdx = i, shouldMerge = !0;\n                break;\n              }\n            }\n\n            if (shouldMerge) {\n              targetMatch.mloc = targetMatch.mloc || {};\n              var locNdx = targetMatch.locator[alternationNdx];\n\n              if (void 0 !== locNdx) {\n                if (\"string\" == typeof locNdx && (locNdx = locNdx.split(\",\")[0]), void 0 === targetMatch.mloc[locNdx] && (targetMatch.mloc[locNdx] = targetMatch.locator.slice()), void 0 !== altMatch) {\n                  for (var ndx in altMatch.mloc) {\n                    \"string\" == typeof ndx && (ndx = ndx.split(\",\")[0]), void 0 === targetMatch.mloc[ndx] && (targetMatch.mloc[ndx] = altMatch.mloc[ndx]);\n                  }\n\n                  targetMatch.locator[alternationNdx] = Object.keys(targetMatch.mloc).join(\",\");\n                }\n\n                return !0;\n              }\n\n              targetMatch.alternation = void 0;\n            }\n\n            return !1;\n          }\n\n          function isSameLevel(targetMatch, altMatch) {\n            if (targetMatch.locator.length !== altMatch.locator.length) return !1;\n\n            for (var locNdx = targetMatch.alternation + 1; locNdx < targetMatch.locator.length; locNdx++) {\n              if (targetMatch.locator[locNdx] !== altMatch.locator[locNdx]) return !1;\n            }\n\n            return !0;\n          }\n\n          if (testPos > pos + opts._maxTestPos) throw \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + maskset.mask;\n          if (testPos === pos && void 0 === match.matches) return matches.push({\n            match: match,\n            locator: loopNdx.reverse(),\n            cd: cacheDependency,\n            mloc: {}\n          }), !0;\n\n          if (void 0 !== match.matches) {\n            if (match.isGroup && quantifierRecurse !== match) {\n              if (match = handleMatch(maskToken.matches[maskToken.matches.indexOf(match) + 1], loopNdx, quantifierRecurse), match) return !0;\n            } else if (match.isOptional) {\n              var optionalToken = match,\n                  mtchsNdx = matches.length;\n\n              if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) {\n                if (matches.forEach(function (mtch, ndx) {\n                  mtchsNdx <= ndx && (mtch.match.optionality = !0);\n                }), latestMatch = matches[matches.length - 1].match, void 0 !== quantifierRecurse || !isFirstMatch(latestMatch, optionalToken)) return !0;\n                insertStop = !0, testPos = pos;\n              }\n            } else if (match.isAlternator) {\n              var alternateToken = match,\n                  malternateMatches = [],\n                  maltMatches,\n                  currentMatches = matches.slice(),\n                  loopNdxCnt = loopNdx.length,\n                  altIndex = 0 < ndxInitializer.length ? ndxInitializer.shift() : -1;\n\n              if (-1 === altIndex || \"string\" == typeof altIndex) {\n                var currentPos = testPos,\n                    ndxInitializerClone = ndxInitializer.slice(),\n                    altIndexArr = [],\n                    amndx;\n                if (\"string\" == typeof altIndex) altIndexArr = altIndex.split(\",\");else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) {\n                  altIndexArr.push(amndx.toString());\n                }\n\n                if (void 0 !== maskset.excludes[pos]) {\n                  for (var altIndexArrClone = altIndexArr.slice(), i = 0, exl = maskset.excludes[pos].length; i < exl; i++) {\n                    var excludeSet = maskset.excludes[pos][i].toString().split(\":\");\n                    loopNdx.length == excludeSet[1] && altIndexArr.splice(altIndexArr.indexOf(excludeSet[0]), 1);\n                  }\n\n                  0 === altIndexArr.length && (delete maskset.excludes[pos], altIndexArr = altIndexArrClone);\n                }\n\n                (!0 === opts.keepStatic || isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic) && (altIndexArr = altIndexArr.slice(0, 1));\n\n                for (var unMatchedAlternation = !1, ndx = 0; ndx < altIndexArr.length; ndx++) {\n                  amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = \"string\" == typeof altIndex && resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(), alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse) ? match = !0 : 0 === ndx && (unMatchedAlternation = !0), maltMatches = matches.slice(), testPos = currentPos, matches = [];\n\n                  for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\n                    var altMatch = maltMatches[ndx1],\n                        dropMatch = !1;\n                    altMatch.match.jit = altMatch.match.jit || unMatchedAlternation, altMatch.alternation = altMatch.alternation || loopNdxCnt, setMergeLocators(altMatch);\n\n                    for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\n                      var altMatch2 = malternateMatches[ndx2];\n\n                      if (\"string\" != typeof altIndex || void 0 !== altMatch.alternation && altIndexArr.includes(altMatch.locator[altMatch.alternation].toString())) {\n                        if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\n                          dropMatch = !0, setMergeLocators(altMatch2, altMatch);\n                          break;\n                        }\n\n                        if (isSubsetOf(altMatch, altMatch2)) {\n                          setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));\n                          break;\n                        }\n\n                        if (isSubsetOf(altMatch2, altMatch)) {\n                          setMergeLocators(altMatch2, altMatch);\n                          break;\n                        }\n\n                        if (staticCanMatchDefinition(altMatch, altMatch2)) {\n                          isSameLevel(altMatch, altMatch2) || void 0 !== el.inputmask.userOptions.keepStatic ? setMergeLocators(altMatch, altMatch2) && (dropMatch = !0, malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch)) : opts.keepStatic = !0;\n                          break;\n                        }\n                      }\n                    }\n\n                    dropMatch || malternateMatches.push(altMatch);\n                  }\n                }\n\n                matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = 0 < matches.length, match = 0 < malternateMatches.length, ndxInitializer = ndxInitializerClone.slice();\n              } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);\n\n              if (match) return !0;\n            } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[maskToken.matches.indexOf(match) - 1]) for (var qt = match, qndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {\n              var tokenGroup = maskToken.matches[maskToken.matches.indexOf(qt) - 1];\n\n              if (match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup), match) {\n                if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx >= qt.quantifier.min, latestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit, latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {\n                  insertStop = !0, testPos = pos;\n                  break;\n                }\n\n                return latestMatch.jit && (maskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch)), !0;\n              }\n            } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse), match) return !0;\n          } else testPos++;\n        }\n\n        for (var tndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) {\n          if (!0 !== maskToken.matches[tndx].isQuantifier) {\n            var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\n            if (match && testPos === pos) return match;\n            if (pos < testPos) break;\n          }\n        }\n      }\n\n      function mergeLocators(pos, tests) {\n        var locator = [],\n            alternation;\n        return Array.isArray(tests) || (tests = [tests]), 0 < tests.length && (void 0 === tests[0].alternation || !0 === opts.keepStatic ? (locator = determineTestTemplate.call(inputmask, pos, tests.slice()).locator.slice(), 0 === locator.length && (locator = tests[0].locator.slice())) : tests.forEach(function (tst) {\n          \"\" !== tst.def && (0 === locator.length ? (alternation = tst.alternation, locator = tst.locator.slice()) : tst.locator[alternation] && -1 === locator[alternation].toString().indexOf(tst.locator[alternation]) && (locator[alternation] += \",\" + tst.locator[alternation]));\n        })), locator;\n      }\n\n      if (-1 < pos && (void 0 === inputmask.maxLength || pos < inputmask.maxLength)) {\n        if (void 0 === ndxIntlzr) {\n          for (var previousPos = pos - 1, test; void 0 === (test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) && -1 < previousPos;) {\n            previousPos--;\n          }\n\n          void 0 !== test && -1 < previousPos && (ndxInitializer = mergeLocators(previousPos, test), cacheDependency = ndxInitializer.join(\"\"), testPos = previousPos);\n        }\n\n        if (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) return maskset.tests[pos];\n\n        for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\n          var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\n          if (match && testPos === pos || pos < testPos) break;\n        }\n      }\n\n      return 0 !== matches.length && !insertStop || matches.push({\n        match: {\n          fn: null,\n          \"static\": !0,\n          optionality: !1,\n          casing: null,\n          def: \"\",\n          placeholder: \"\"\n        },\n        locator: [],\n        mloc: {},\n        cd: cacheDependency\n      }), void 0 !== ndxIntlzr && maskset.tests[pos] ? $.extend(!0, [], matches) : (maskset.tests[pos] = $.extend(!0, [], matches), maskset.tests[pos]);\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.determineTestTemplate = determineTestTemplate, exports.getDecisionTaker = getDecisionTaker, exports.getMaskTemplate = getMaskTemplate, exports.getPlaceholder = getPlaceholder, exports.getTest = getTest, exports.getTests = getTests, exports.getTestTemplate = getTestTemplate;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.alternate = alternate, exports.checkAlternationMatch = checkAlternationMatch, exports.isComplete = isComplete, exports.isValid = isValid, exports.refreshFromBuffer = refreshFromBuffer, exports.revalidateMask = revalidateMask, exports.handleRemove = handleRemove;\n\n    var _validationTests = __webpack_require__(3),\n        _keycode = _interopRequireDefault(__webpack_require__(0)),\n        _positioning = __webpack_require__(2),\n        _eventhandlers = __webpack_require__(7);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    function alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) {\n      var inputmask = this,\n          $ = this.dependencyLib,\n          opts = this.opts,\n          maskset = this.maskset,\n          validPsClone = $.extend(!0, {}, maskset.validPositions),\n          tstClone = $.extend(!0, {}, maskset.tests),\n          lastAlt,\n          alternation,\n          isValidRslt = !1,\n          returnRslt = !1,\n          altPos,\n          prevAltPos,\n          i,\n          validPos,\n          decisionPos,\n          lAltPos = void 0 !== rAltPos ? rAltPos : _positioning.getLastValidPosition.call(this),\n          nextPos,\n          input,\n          begin,\n          end;\n      if (selection && (begin = selection.begin, end = selection.end, selection.begin > selection.end && (begin = selection.end, end = selection.begin)), -1 === lAltPos && void 0 === rAltPos) lastAlt = 0, prevAltPos = _validationTests.getTest.call(this, lastAlt), alternation = prevAltPos.alternation;else for (; 0 <= lAltPos; lAltPos--) {\n        if (altPos = maskset.validPositions[lAltPos], altPos && void 0 !== altPos.alternation) {\n          if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;\n          lastAlt = lAltPos, alternation = maskset.validPositions[lastAlt].alternation, prevAltPos = altPos;\n        }\n      }\n\n      if (void 0 !== alternation) {\n        decisionPos = parseInt(lastAlt), maskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [], !0 !== maskPos && maskset.excludes[decisionPos].push((0, _validationTests.getDecisionTaker)(prevAltPos) + \":\" + prevAltPos.alternation);\n        var validInputs = [],\n            resultPos = -1;\n\n        for (i = decisionPos; i < _positioning.getLastValidPosition.call(this, void 0, !0) + 1; i++) {\n          -1 === resultPos && maskPos <= i && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1), validPos = maskset.validPositions[i], validPos && !0 !== validPos.generatedInput && (void 0 === selection || i < begin || end <= i) && validInputs.push(validPos.input), delete maskset.validPositions[i];\n        }\n\n        for (-1 === resultPos && void 0 !== c && (validInputs.push(c), resultPos = validInputs.length - 1); void 0 !== maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10;) {\n          for (maskset.tests = {}, _positioning.resetMaskSet.call(this, !0), isValidRslt = !0, i = 0; i < validInputs.length && (nextPos = isValidRslt.caret || _positioning.getLastValidPosition.call(this, void 0, !0) + 1, input = validInputs[i], isValidRslt = isValid.call(this, nextPos, input, !1, fromIsValid, !0)); i++) {\n            i === resultPos && (returnRslt = isValidRslt), 1 == maskPos && isValidRslt && (returnRslt = {\n              caretPos: i\n            });\n          }\n\n          if (isValidRslt) break;\n\n          if (_positioning.resetMaskSet.call(this), prevAltPos = _validationTests.getTest.call(this, decisionPos), maskset.validPositions = $.extend(!0, {}, validPsClone), maskset.tests = $.extend(!0, {}, tstClone), !maskset.excludes[decisionPos]) {\n            returnRslt = alternate.call(this, maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\n            break;\n          }\n\n          var decisionTaker = (0, _validationTests.getDecisionTaker)(prevAltPos);\n\n          if (-1 !== maskset.excludes[decisionPos].indexOf(decisionTaker + \":\" + prevAltPos.alternation)) {\n            returnRslt = alternate.call(this, maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\n            break;\n          }\n\n          for (maskset.excludes[decisionPos].push(decisionTaker + \":\" + prevAltPos.alternation), i = decisionPos; i < _positioning.getLastValidPosition.call(this, void 0, !0) + 1; i++) {\n            delete maskset.validPositions[i];\n          }\n        }\n      }\n\n      return returnRslt && !1 === opts.keepStatic || delete maskset.excludes[decisionPos], returnRslt;\n    }\n\n    function casing(elem, test, pos) {\n      var opts = this.opts,\n          maskset = this.maskset;\n\n      switch (opts.casing || test.casing) {\n        case \"upper\":\n          elem = elem.toUpperCase();\n          break;\n\n        case \"lower\":\n          elem = elem.toLowerCase();\n          break;\n\n        case \"title\":\n          var posBefore = maskset.validPositions[pos - 1];\n          elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(_keycode[\"default\"].SPACE) ? elem.toUpperCase() : elem.toLowerCase();\n          break;\n\n        default:\n          if (\"function\" == typeof opts.casing) {\n            var args = Array.prototype.slice.call(arguments);\n            args.push(maskset.validPositions), elem = opts.casing.apply(this, args);\n          }\n\n      }\n\n      return elem;\n    }\n\n    function checkAlternationMatch(altArr1, altArr2, na) {\n      for (var opts = this.opts, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = void 0 !== na ? na.split(\",\") : [], naNdx, i = 0; i < naArr.length; i++) {\n        -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);\n      }\n\n      for (var alndx = 0; alndx < altArr1.length; alndx++) {\n        if (altArrC.includes(altArr1[alndx])) {\n          isMatch = !0;\n          break;\n        }\n      }\n\n      return isMatch;\n    }\n\n    function handleRemove(input, k, pos, strict, fromIsValid) {\n      var inputmask = this,\n          maskset = this.maskset,\n          opts = this.opts;\n\n      if ((opts.numericInput || this.isRTL) && (k === _keycode[\"default\"].BACKSPACE ? k = _keycode[\"default\"].DELETE : k === _keycode[\"default\"].DELETE && (k = _keycode[\"default\"].BACKSPACE), this.isRTL)) {\n        var pend = pos.end;\n        pos.end = pos.begin, pos.begin = pend;\n      }\n\n      var lvp = _positioning.getLastValidPosition.call(this, void 0, !0),\n          offset;\n\n      if (pos.end >= _positioning.getBuffer.call(this).length && lvp >= pos.end && (pos.end = lvp + 1), k === _keycode[\"default\"].BACKSPACE ? pos.end - pos.begin < 1 && (pos.begin = _positioning.seekPrevious.call(this, pos.begin)) : k === _keycode[\"default\"].DELETE && pos.begin === pos.end && (pos.end = _positioning.isMask.call(this, pos.end, !0, !0) ? pos.end + 1 : _positioning.seekNext.call(this, pos.end) + 1), !1 !== (offset = revalidateMask.call(this, pos))) {\n        if (!0 !== strict && !1 !== opts.keepStatic || null !== opts.regex && -1 !== _validationTests.getTest.call(this, pos.begin).match.def.indexOf(\"|\")) {\n          var result = alternate.call(this, !0);\n\n          if (result) {\n            var newPos = void 0 !== result.caret ? result.caret : result.pos ? _positioning.seekNext.call(this, result.pos.begin ? result.pos.begin : result.pos) : _positioning.getLastValidPosition.call(this, -1, !0);\n            (k !== _keycode[\"default\"].DELETE || pos.begin > newPos) && pos.begin;\n          }\n        }\n\n        !0 !== strict && (maskset.p = k === _keycode[\"default\"].DELETE ? pos.begin + offset : pos.begin);\n      }\n    }\n\n    function isComplete(buffer) {\n      var inputmask = this,\n          opts = this.opts,\n          maskset = this.maskset;\n      if (\"function\" == typeof opts.isComplete) return opts.isComplete(buffer, opts);\n\n      if (\"*\" !== opts.repeat) {\n        var complete = !1,\n            lrp = _positioning.determineLastRequiredPosition.call(this, !0),\n            aml = _positioning.seekPrevious.call(this, lrp.l);\n\n        if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\n          complete = !0;\n\n          for (var i = 0; i <= aml; i++) {\n            var test = _validationTests.getTestTemplate.call(this, i).match;\n\n            if (!0 !== test[\"static\"] && void 0 === maskset.validPositions[i] && !0 !== test.optionality && !0 !== test.optionalQuantifier || !0 === test[\"static\"] && buffer[i] !== _validationTests.getPlaceholder.call(this, i, test)) {\n              complete = !1;\n              break;\n            }\n          }\n        }\n\n        return complete;\n      }\n    }\n\n    function isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly, fromCheckval) {\n      var inputmask = this,\n          $ = this.dependencyLib,\n          opts = this.opts,\n          el = inputmask.el,\n          maskset = inputmask.maskset;\n\n      function isSelection(posObj) {\n        return inputmask.isRTL ? 1 < posObj.begin - posObj.end || posObj.begin - posObj.end == 1 : 1 < posObj.end - posObj.begin || posObj.end - posObj.begin == 1;\n      }\n\n      strict = !0 === strict;\n      var maskPos = pos;\n\n      function processCommandObject(commandObj) {\n        if (void 0 !== commandObj) {\n          if (void 0 !== commandObj.remove && (Array.isArray(commandObj.remove) || (commandObj.remove = [commandObj.remove]), commandObj.remove.sort(function (a, b) {\n            return b.pos - a.pos;\n          }).forEach(function (lmnt) {\n            revalidateMask.call(inputmask, {\n              begin: lmnt,\n              end: lmnt + 1\n            });\n          }), commandObj.remove = void 0), void 0 !== commandObj.insert && (Array.isArray(commandObj.insert) || (commandObj.insert = [commandObj.insert]), commandObj.insert.sort(function (a, b) {\n            return a.pos - b.pos;\n          }).forEach(function (lmnt) {\n            \"\" !== lmnt.c && isValid.call(inputmask, lmnt.pos, lmnt.c, void 0 === lmnt.strict || lmnt.strict, void 0 !== lmnt.fromIsValid ? lmnt.fromIsValid : fromIsValid);\n          }), commandObj.insert = void 0), commandObj.refreshFromBuffer && commandObj.buffer) {\n            var refresh = commandObj.refreshFromBuffer;\n            refreshFromBuffer.call(inputmask, !0 === refresh ? refresh : refresh.start, refresh.end, commandObj.buffer), commandObj.refreshFromBuffer = void 0;\n          }\n\n          void 0 !== commandObj.rewritePosition && (maskPos = commandObj.rewritePosition, commandObj = !0);\n        }\n\n        return commandObj;\n      }\n\n      function _isValid(position, c, strict) {\n        var rslt = !1;\n        return _validationTests.getTests.call(inputmask, position).every(function (tst, ndx) {\n          var test = tst.match;\n          if (_positioning.getBuffer.call(inputmask, !0), rslt = null != test.fn ? test.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && \"\" !== test.def && {\n            c: _validationTests.getPlaceholder.call(inputmask, position, test, !0) || test.def,\n            pos: position\n          }, !1 === rslt) return !0;\n          var elem = void 0 !== rslt.c ? rslt.c : c,\n              validatedPos = position;\n          return elem = elem === opts.skipOptionalPartCharacter && !0 === test[\"static\"] ? _validationTests.getPlaceholder.call(inputmask, position, test, !0) || test.def : elem, rslt = processCommandObject(rslt), !0 !== rslt && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos), !0 !== rslt && void 0 === rslt.pos && void 0 === rslt.c || !1 === revalidateMask.call(inputmask, pos, $.extend({}, tst, {\n            input: casing.call(inputmask, elem, test, validatedPos)\n          }), fromIsValid, validatedPos) && (rslt = !1), !1;\n        }), rslt;\n      }\n\n      void 0 !== pos.begin && (maskPos = inputmask.isRTL ? pos.end : pos.begin);\n      var result = !0,\n          positionsClone = $.extend(!0, {}, maskset.validPositions);\n      if (!1 === opts.keepStatic && void 0 !== maskset.excludes[maskPos] && !0 !== fromAlternate && !0 !== fromIsValid) for (var i = maskPos; i < (inputmask.isRTL ? pos.begin : pos.end); i++) {\n        void 0 !== maskset.excludes[i] && (maskset.excludes[i] = void 0, delete maskset.tests[i]);\n      }\n\n      if (\"function\" == typeof opts.preValidation && !0 !== fromIsValid && !0 !== validateOnly && (result = opts.preValidation.call(el, _positioning.getBuffer.call(inputmask), maskPos, c, isSelection(pos), opts, maskset, pos, strict || fromAlternate), result = processCommandObject(result)), !0 === result) {\n        if (void 0 === inputmask.maxLength || maskPos < inputmask.maxLength) {\n          if (result = _isValid(maskPos, c, strict), (!strict || !0 === fromIsValid) && !1 === result && !0 !== validateOnly) {\n            var currentPosValid = maskset.validPositions[maskPos];\n\n            if (!currentPosValid || !0 !== currentPosValid.match[\"static\"] || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {\n              if (opts.insertMode || void 0 === maskset.validPositions[_positioning.seekNext.call(inputmask, maskPos)] || pos.end > maskPos) {\n                var skip = !1;\n                if (maskset.jitOffset[maskPos] && void 0 === maskset.validPositions[_positioning.seekNext.call(inputmask, maskPos)] && (result = isValid.call(inputmask, maskPos + maskset.jitOffset[maskPos], c, !0), !1 !== result && (!0 !== fromAlternate && (result.caret = maskPos), skip = !0)), pos.end > maskPos && (maskset.validPositions[maskPos] = void 0), !skip && !_positioning.isMask.call(inputmask, maskPos, opts.keepStatic && 0 === maskPos)) for (var nPos = maskPos + 1, snPos = _positioning.seekNext.call(inputmask, maskPos, !1, 0 !== maskPos); nPos <= snPos; nPos++) {\n                  if (result = _isValid(nPos, c, strict), !1 !== result) {\n                    result = trackbackPositions.call(inputmask, maskPos, void 0 !== result.pos ? result.pos : nPos) || result, maskPos = nPos;\n                    break;\n                  }\n                }\n              }\n            } else result = {\n              caret: _positioning.seekNext.call(inputmask, maskPos)\n            };\n          }\n        } else result = !1;\n\n        !1 !== result || !opts.keepStatic || !isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && 0 !== maskPos || strict || !0 === fromAlternate ? isSelection(pos) && maskset.tests[maskPos] && 1 < maskset.tests[maskPos].length && opts.keepStatic && !strict && !0 !== fromAlternate && (result = alternate.call(inputmask, !0)) : result = alternate.call(inputmask, maskPos, c, strict, fromIsValid, void 0, pos), !0 === result && (result = {\n          pos: maskPos\n        });\n      }\n\n      if (\"function\" == typeof opts.postValidation && !0 !== fromIsValid && !0 !== validateOnly) {\n        var postResult = opts.postValidation.call(el, _positioning.getBuffer.call(inputmask, !0), void 0 !== pos.begin ? inputmask.isRTL ? pos.end : pos.begin : pos, c, result, opts, maskset, strict, fromCheckval);\n        void 0 !== postResult && (result = !0 === postResult ? result : postResult);\n      }\n\n      result && void 0 === result.pos && (result.pos = maskPos), !1 === result || !0 === validateOnly ? (_positioning.resetMaskSet.call(inputmask, !0), maskset.validPositions = $.extend(!0, {}, positionsClone)) : trackbackPositions.call(inputmask, void 0, maskPos, !0);\n      var endResult = processCommandObject(result);\n      return endResult;\n    }\n\n    function positionCanMatchDefinition(pos, testDefinition, opts) {\n      for (var inputmask = this, maskset = this.maskset, valid = !1, tests = _validationTests.getTests.call(this, pos), tndx = 0; tndx < tests.length; tndx++) {\n        if (tests[tndx].match && (!(tests[tndx].match.nativeDef !== testDefinition.match[opts.shiftPositions ? \"def\" : \"nativeDef\"] || opts.shiftPositions && testDefinition.match[\"static\"]) || tests[tndx].match.nativeDef === testDefinition.match.nativeDef)) {\n          valid = !0;\n          break;\n        }\n\n        if (tests[tndx].match && tests[tndx].match.def === testDefinition.match.nativeDef) {\n          valid = void 0;\n          break;\n        }\n      }\n\n      return !1 === valid && void 0 !== maskset.jitOffset[pos] && (valid = positionCanMatchDefinition.call(this, pos + maskset.jitOffset[pos], testDefinition, opts)), valid;\n    }\n\n    function refreshFromBuffer(start, end, buffer) {\n      var inputmask = this,\n          maskset = this.maskset,\n          opts = this.opts,\n          $ = this.dependencyLib,\n          el = this.el,\n          i,\n          p,\n          skipOptionalPartCharacter = opts.skipOptionalPartCharacter,\n          bffr = this.isRTL ? buffer.slice().reverse() : buffer;\n      if (opts.skipOptionalPartCharacter = \"\", !0 === start) _positioning.resetMaskSet.call(this), maskset.tests = {}, start = 0, end = buffer.length, p = _positioning.determineNewCaretPosition.call(this, {\n        begin: 0,\n        end: 0\n      }, !1).begin;else {\n        for (i = start; i < end; i++) {\n          delete maskset.validPositions[i];\n        }\n\n        p = start;\n      }\n      var keypress = new $.Event(\"keypress\");\n\n      for (i = start; i < end; i++) {\n        keypress.which = bffr[i].toString().charCodeAt(0), this.ignorable = !1;\n\n        var valResult = _eventhandlers.EventHandlers.keypressEvent.call(el, keypress, !0, !1, !1, p);\n\n        !1 !== valResult && (p = valResult.forwardPosition);\n      }\n\n      opts.skipOptionalPartCharacter = skipOptionalPartCharacter;\n    }\n\n    function trackbackPositions(originalPos, newPos, fillOnly) {\n      var inputmask = this,\n          maskset = this.maskset,\n          $ = this.dependencyLib;\n      if (void 0 === originalPos) for (originalPos = newPos - 1; 0 < originalPos && !maskset.validPositions[originalPos]; originalPos--) {\n        ;\n      }\n\n      for (var ps = originalPos; ps < newPos; ps++) {\n        if (void 0 === maskset.validPositions[ps] && !_positioning.isMask.call(this, ps, !0)) {\n          var vp = 0 == ps ? _validationTests.getTest.call(this, ps) : maskset.validPositions[ps - 1];\n\n          if (vp) {\n            var tests = _validationTests.getTests.call(this, ps).slice();\n\n            \"\" === tests[tests.length - 1].match.def && tests.pop();\n\n            var bestMatch = _validationTests.determineTestTemplate.call(this, ps, tests),\n                np;\n\n            if (bestMatch && (!0 !== bestMatch.match.jit || \"master\" === bestMatch.match.newBlockMarker && (np = maskset.validPositions[ps + 1]) && !0 === np.match.optionalQuantifier) && (bestMatch = $.extend({}, bestMatch, {\n              input: _validationTests.getPlaceholder.call(this, ps, bestMatch.match, !0) || bestMatch.match.def\n            }), bestMatch.generatedInput = !0, revalidateMask.call(this, ps, bestMatch, !0), !0 !== fillOnly)) {\n              var cvpInput = maskset.validPositions[newPos].input;\n              return maskset.validPositions[newPos] = void 0, isValid.call(this, newPos, cvpInput, !0, !0);\n            }\n          }\n        }\n      }\n    }\n\n    function revalidateMask(pos, validTest, fromIsValid, validatedPos) {\n      var inputmask = this,\n          maskset = this.maskset,\n          opts = this.opts,\n          $ = this.dependencyLib;\n\n      function IsEnclosedStatic(pos, valids, selection) {\n        var posMatch = valids[pos];\n        if (void 0 === posMatch || !0 !== posMatch.match[\"static\"] || !0 === posMatch.match.optionality || void 0 !== valids[0] && void 0 !== valids[0].alternation) return !1;\n        var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && !0 === valids[pos - 1].match[\"static\"] && valids[pos - 1] : valids[pos - 1],\n            nextMatch = selection.end > pos + 1 ? valids[pos + 1] && !0 === valids[pos + 1].match[\"static\"] && valids[pos + 1] : valids[pos + 1];\n        return prevMatch && nextMatch;\n      }\n\n      var offset = 0,\n          begin = void 0 !== pos.begin ? pos.begin : pos,\n          end = void 0 !== pos.end ? pos.end : pos;\n\n      if (pos.begin > pos.end && (begin = pos.end, end = pos.begin), validatedPos = void 0 !== validatedPos ? validatedPos : begin, begin !== end || opts.insertMode && void 0 !== maskset.validPositions[validatedPos] && void 0 === fromIsValid || void 0 === validTest) {\n        var positionsClone = $.extend(!0, {}, maskset.validPositions),\n            lvp = _positioning.getLastValidPosition.call(this, void 0, !0),\n            i;\n\n        for (maskset.p = begin, i = lvp; begin <= i; i--) {\n          delete maskset.validPositions[i], void 0 === validTest && delete maskset.tests[i + 1];\n        }\n\n        var valid = !0,\n            j = validatedPos,\n            posMatch = j,\n            t,\n            canMatch;\n\n        for (validTest && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest), posMatch++, j++), i = validTest ? end : end - 1; i <= lvp; i++) {\n          if (void 0 !== (t = positionsClone[i]) && !0 !== t.generatedInput && (end <= i || begin <= i && IsEnclosedStatic(i, positionsClone, {\n            begin: begin,\n            end: end\n          }))) {\n            for (; \"\" !== _validationTests.getTest.call(this, posMatch).match.def;) {\n              if (!1 !== (canMatch = positionCanMatchDefinition.call(this, posMatch, t, opts)) || \"+\" === t.match.def) {\n                \"+\" === t.match.def && _positioning.getBuffer.call(this, !0);\n                var result = isValid.call(this, posMatch, t.input, \"+\" !== t.match.def, \"+\" !== t.match.def);\n                if (valid = !1 !== result, j = (result.pos || posMatch) + 1, !valid && canMatch) break;\n              } else valid = !1;\n\n              if (valid) {\n                void 0 === validTest && t.match[\"static\"] && i === pos.begin && offset++;\n                break;\n              }\n\n              if (!valid && posMatch > maskset.maskLength) break;\n              posMatch++;\n            }\n\n            \"\" == _validationTests.getTest.call(this, posMatch).match.def && (valid = !1), posMatch = j;\n          }\n\n          if (!valid) break;\n        }\n\n        if (!valid) return maskset.validPositions = $.extend(!0, {}, positionsClone), _positioning.resetMaskSet.call(this, !0), !1;\n      } else validTest && _validationTests.getTest.call(this, validatedPos).match.cd === validTest.match.cd && (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest));\n\n      return _positioning.resetMaskSet.call(this, !0), offset;\n    }\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.applyInputValue = applyInputValue, exports.clearOptionalTail = clearOptionalTail, exports.checkVal = checkVal, exports.HandleNativePlaceholder = HandleNativePlaceholder, exports.unmaskedvalue = unmaskedvalue, exports.writeBuffer = writeBuffer;\n\n    var _keycode = _interopRequireDefault(__webpack_require__(0)),\n        _validationTests = __webpack_require__(3),\n        _positioning = __webpack_require__(2),\n        _validation = __webpack_require__(4),\n        _environment = __webpack_require__(8),\n        _eventhandlers = __webpack_require__(7);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    function applyInputValue(input, value) {\n      var inputmask = input ? input.inputmask : this,\n          opts = inputmask.opts;\n      input.inputmask.refreshValue = !1, \"function\" == typeof opts.onBeforeMask && (value = opts.onBeforeMask.call(inputmask, value, opts) || value), value = value.toString().split(\"\"), checkVal(input, !0, !1, value), inputmask.undoValue = _positioning.getBuffer.call(inputmask).join(\"\"), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === _positioning.getBufferTemplate.call(inputmask).join(\"\") && -1 === _positioning.getLastValidPosition.call(inputmask) && input.inputmask._valueSet(\"\");\n    }\n\n    function clearOptionalTail(buffer) {\n      var inputmask = this;\n      buffer.length = 0;\n\n      for (var template = _validationTests.getMaskTemplate.call(this, !0, 0, !0, void 0, !0), lmnt; void 0 !== (lmnt = template.shift());) {\n        buffer.push(lmnt);\n      }\n\n      return buffer;\n    }\n\n    function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\n      var inputmask = input ? input.inputmask : this,\n          maskset = inputmask.maskset,\n          opts = inputmask.opts,\n          $ = inputmask.dependencyLib,\n          inputValue = nptvl.slice(),\n          charCodes = \"\",\n          initialNdx = -1,\n          result = void 0,\n          skipOptionalPartCharacter = opts.skipOptionalPartCharacter;\n\n      function isTemplateMatch(ndx, charCodes) {\n        for (var targetTemplate = _validationTests.getMaskTemplate.call(inputmask, !0, 0).slice(ndx, _positioning.seekNext.call(inputmask, ndx)).join(\"\").replace(/'/g, \"\"), charCodeNdx = targetTemplate.indexOf(charCodes); 0 < charCodeNdx && \" \" === targetTemplate[charCodeNdx - 1];) {\n          charCodeNdx--;\n        }\n\n        var match = 0 === charCodeNdx && !_positioning.isMask.call(inputmask, ndx) && (_validationTests.getTest.call(inputmask, ndx).match.nativeDef === charCodes.charAt(0) || !0 === _validationTests.getTest.call(inputmask, ndx).match[\"static\"] && _validationTests.getTest.call(inputmask, ndx).match.nativeDef === \"'\" + charCodes.charAt(0) || \" \" === _validationTests.getTest.call(inputmask, ndx).match.nativeDef && (_validationTests.getTest.call(inputmask, ndx + 1).match.nativeDef === charCodes.charAt(0) || !0 === _validationTests.getTest.call(inputmask, ndx + 1).match[\"static\"] && _validationTests.getTest.call(inputmask, ndx + 1).match.nativeDef === \"'\" + charCodes.charAt(0)));\n\n        if (!match && 0 < charCodeNdx && !_positioning.isMask.call(inputmask, ndx, !1, !0)) {\n          var nextPos = _positioning.seekNext.call(inputmask, ndx);\n\n          inputmask.caretPos.begin < nextPos && (inputmask.caretPos = {\n            begin: nextPos\n          });\n        }\n\n        return match;\n      }\n\n      opts.skipOptionalPartCharacter = \"\", _positioning.resetMaskSet.call(inputmask), maskset.tests = {}, initialNdx = opts.radixPoint ? _positioning.determineNewCaretPosition.call(inputmask, {\n        begin: 0,\n        end: 0\n      }).begin : 0, maskset.p = initialNdx, inputmask.caretPos = {\n        begin: initialNdx\n      };\n      var staticMatches = [],\n          prevCaretPos = inputmask.caretPos;\n\n      if (inputValue.forEach(function (charCode, ndx) {\n        if (void 0 !== charCode) if (void 0 === maskset.validPositions[ndx] && inputValue[ndx] === _validationTests.getPlaceholder.call(inputmask, ndx) && _positioning.isMask.call(inputmask, ndx, !0) && !1 === _validation.isValid.call(inputmask, ndx, inputValue[ndx], !0, void 0, void 0, !0)) maskset.p++;else {\n          var keypress = new $.Event(\"_checkval\");\n          keypress.which = charCode.toString().charCodeAt(0), charCodes += charCode;\n\n          var lvp = _positioning.getLastValidPosition.call(inputmask, void 0, !0);\n\n          isTemplateMatch(initialNdx, charCodes) ? result = _eventhandlers.EventHandlers.keypressEvent.call(input || inputmask, keypress, !0, !1, strict, lvp + 1) : (result = _eventhandlers.EventHandlers.keypressEvent.call(input || inputmask, keypress, !0, !1, strict, inputmask.caretPos.begin), result && (initialNdx = inputmask.caretPos.begin + 1, charCodes = \"\")), result ? (void 0 !== result.pos && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match[\"static\"] && void 0 === maskset.validPositions[result.pos].alternation && (staticMatches.push(result.pos), inputmask.isRTL || (result.forwardPosition = result.pos + 1)), writeBuffer.call(inputmask, void 0, _positioning.getBuffer.call(inputmask), result.forwardPosition, keypress, !1), inputmask.caretPos = {\n            begin: result.forwardPosition,\n            end: result.forwardPosition\n          }, prevCaretPos = inputmask.caretPos) : inputmask.caretPos = prevCaretPos;\n        }\n      }), 0 < staticMatches.length) {\n        var sndx,\n            validPos,\n            nextValid = _positioning.seekNext.call(inputmask, -1, void 0, !1);\n\n        if (!_validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && staticMatches.length <= nextValid || _validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && 0 < staticMatches.length && staticMatches.length !== nextValid && 0 === staticMatches[0]) for (var nextSndx = nextValid; void 0 !== (sndx = staticMatches.shift());) {\n          var keypress = new $.Event(\"_checkval\");\n          if (validPos = maskset.validPositions[sndx], validPos.generatedInput = !0, keypress.which = validPos.input.charCodeAt(0), result = _eventhandlers.EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, nextSndx), result && void 0 !== result.pos && result.pos !== sndx && maskset.validPositions[result.pos] && !0 === maskset.validPositions[result.pos].match[\"static\"]) staticMatches.push(result.pos);else if (!result) break;\n          nextSndx++;\n        }\n      }\n\n      writeOut && writeBuffer.call(inputmask, input, _positioning.getBuffer.call(inputmask), result ? result.forwardPosition : inputmask.caretPos.begin, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && \"input\" === initiatingEvent.type && inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join(\"\")), opts.skipOptionalPartCharacter = skipOptionalPartCharacter;\n    }\n\n    function HandleNativePlaceholder(npt, value) {\n      var inputmask = npt ? npt.inputmask : this;\n\n      if (_environment.ie) {\n        if (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || \"\" === npt.placeholder)) {\n          var buffer = _positioning.getBuffer.call(inputmask).slice(),\n              nptValue = npt.inputmask._valueGet();\n\n          if (nptValue !== value) {\n            var lvp = _positioning.getLastValidPosition.call(inputmask);\n\n            -1 === lvp && nptValue === _positioning.getBufferTemplate.call(inputmask).join(\"\") ? buffer = [] : -1 !== lvp && clearOptionalTail.call(inputmask, buffer), writeBuffer(npt, buffer);\n          }\n        }\n      } else npt.placeholder !== value && (npt.placeholder = value, \"\" === npt.placeholder && npt.removeAttribute(\"placeholder\"));\n    }\n\n    function unmaskedvalue(input) {\n      var inputmask = input ? input.inputmask : this,\n          opts = inputmask.opts,\n          maskset = inputmask.maskset;\n\n      if (input) {\n        if (void 0 === input.inputmask) return input.value;\n        input.inputmask && input.inputmask.refreshValue && applyInputValue(input, input.inputmask._valueGet(!0));\n      }\n\n      var umValue = [],\n          vps = maskset.validPositions;\n\n      for (var pndx in vps) {\n        vps[pndx] && vps[pndx].match && (1 != vps[pndx].match[\"static\"] || Array.isArray(maskset.metadata) && !0 !== vps[pndx].generatedInput) && umValue.push(vps[pndx].input);\n      }\n\n      var unmaskedValue = 0 === umValue.length ? \"\" : (inputmask.isRTL ? umValue.reverse() : umValue).join(\"\");\n\n      if (\"function\" == typeof opts.onUnMask) {\n        var bufferValue = (inputmask.isRTL ? _positioning.getBuffer.call(inputmask).slice().reverse() : _positioning.getBuffer.call(inputmask)).join(\"\");\n        unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\n      }\n\n      return unmaskedValue;\n    }\n\n    function writeBuffer(input, buffer, caretPos, event, triggerEvents) {\n      var inputmask = input ? input.inputmask : this,\n          opts = inputmask.opts,\n          $ = inputmask.dependencyLib;\n\n      if (event && \"function\" == typeof opts.onBeforeWrite) {\n        var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\n\n        if (result) {\n          if (result.refreshFromBuffer) {\n            var refresh = result.refreshFromBuffer;\n            _validation.refreshFromBuffer.call(inputmask, !0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer), buffer = _positioning.getBuffer.call(inputmask, !0);\n          }\n\n          void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos);\n        }\n      }\n\n      if (void 0 !== input && (input.inputmask._valueSet(buffer.join(\"\")), void 0 === caretPos || void 0 !== event && \"blur\" === event.type || _positioning.caret.call(inputmask, input, caretPos, void 0, void 0, void 0 !== event && \"keydown\" === event.type && (event.keyCode === _keycode[\"default\"].DELETE || event.keyCode === _keycode[\"default\"].BACKSPACE)), !0 === triggerEvents)) {\n        var $input = $(input),\n            nptVal = input.inputmask._valueGet();\n\n        input.inputmask.skipInputEvent = !0, $input.trigger(\"input\"), setTimeout(function () {\n          nptVal === _positioning.getBufferTemplate.call(inputmask).join(\"\") ? $input.trigger(\"cleared\") : !0 === _validation.isComplete.call(inputmask, buffer) && $input.trigger(\"complete\");\n        }, 0);\n      }\n    }\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = void 0;\n\n    var _default = \"undefined\" != typeof window ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\n\n    exports[\"default\"] = _default;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.EventHandlers = void 0;\n\n    var _positioning = __webpack_require__(2),\n        _keycode = _interopRequireDefault(__webpack_require__(0)),\n        _environment = __webpack_require__(8),\n        _validation = __webpack_require__(4),\n        _inputHandling = __webpack_require__(5),\n        _validationTests = __webpack_require__(3);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var EventHandlers = {\n      keydownEvent: function keydownEvent(e) {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts,\n            $ = inputmask.dependencyLib,\n            maskset = inputmask.maskset,\n            input = this,\n            $input = $(input),\n            k = e.keyCode,\n            pos = _positioning.caret.call(inputmask, input),\n            kdResult = opts.onKeyDown.call(this, e, _positioning.getBuffer.call(inputmask), pos, opts);\n\n        if (void 0 !== kdResult) return kdResult;\n        if (k === _keycode[\"default\"].BACKSPACE || k === _keycode[\"default\"].DELETE || _environment.iphone && k === _keycode[\"default\"].BACKSPACE_SAFARI || e.ctrlKey && k === _keycode[\"default\"].X && !(\"oncut\" in input)) e.preventDefault(), _validation.handleRemove.call(inputmask, input, k, pos), (0, _inputHandling.writeBuffer)(input, _positioning.getBuffer.call(inputmask, !0), maskset.p, e, input.inputmask._valueGet() !== _positioning.getBuffer.call(inputmask).join(\"\"));else if (k === _keycode[\"default\"].END || k === _keycode[\"default\"].PAGE_DOWN) {\n          e.preventDefault();\n\n          var caretPos = _positioning.seekNext.call(inputmask, _positioning.getLastValidPosition.call(inputmask));\n\n          _positioning.caret.call(inputmask, input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);\n        } else k === _keycode[\"default\"].HOME && !e.shiftKey || k === _keycode[\"default\"].PAGE_UP ? (e.preventDefault(), _positioning.caret.call(inputmask, input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === _keycode[\"default\"].ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? ((0, _inputHandling.checkVal)(input, !0, !1, inputmask.undoValue.split(\"\")), $input.trigger(\"click\")) : !0 === opts.tabThrough && k === _keycode[\"default\"].TAB ? !0 === e.shiftKey ? (pos.end = _positioning.seekPrevious.call(inputmask, pos.end, !0), !0 === _validationTests.getTest.call(inputmask, pos.end - 1).match[\"static\"] && pos.end--, pos.begin = _positioning.seekPrevious.call(inputmask, pos.end, !0), 0 <= pos.begin && 0 < pos.end && (e.preventDefault(), _positioning.caret.call(inputmask, input, pos.begin, pos.end))) : (pos.begin = _positioning.seekNext.call(inputmask, pos.begin, !0), pos.end = _positioning.seekNext.call(inputmask, pos.begin, !0), pos.end < maskset.maskLength && pos.end--, pos.begin <= maskset.maskLength && (e.preventDefault(), _positioning.caret.call(inputmask, input, pos.begin, pos.end))) : e.shiftKey || opts.insertModeVisual && !1 === opts.insertMode && (k === _keycode[\"default\"].RIGHT ? setTimeout(function () {\n          var caretPos = _positioning.caret.call(inputmask, input);\n\n          _positioning.caret.call(inputmask, input, caretPos.begin);\n        }, 0) : k === _keycode[\"default\"].LEFT && setTimeout(function () {\n          var caretPos_begin = _positioning.translatePosition.call(inputmask, input.inputmask.caretPos.begin),\n              caretPos_end = _positioning.translatePosition.call(inputmask, input.inputmask.caretPos.end);\n\n          inputmask.isRTL ? _positioning.caret.call(inputmask, input, caretPos_begin + (caretPos_begin === maskset.maskLength ? 0 : 1)) : _positioning.caret.call(inputmask, input, caretPos_begin - (0 === caretPos_begin ? 0 : 1));\n        }, 0));\n        inputmask.ignorable = opts.ignorables.includes(k);\n      },\n      keypressEvent: function keypressEvent(e, checkval, writeOut, strict, ndx) {\n        var inputmask = this.inputmask || this,\n            opts = inputmask.opts,\n            $ = inputmask.dependencyLib,\n            maskset = inputmask.maskset,\n            input = inputmask.el,\n            $input = $(input),\n            k = e.which || e.charCode || e.keyCode;\n        if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || inputmask.ignorable)) return k === _keycode[\"default\"].ENTER && inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join(\"\") && (inputmask.undoValue = _positioning.getBuffer.call(inputmask).join(\"\"), setTimeout(function () {\n          $input.trigger(\"change\");\n        }, 0)), inputmask.skipInputEvent = !0, !0;\n\n        if (k) {\n          44 !== k && 46 !== k || 3 !== e.location || \"\" === opts.radixPoint || (k = opts.radixPoint.charCodeAt(0));\n          var pos = checkval ? {\n            begin: ndx,\n            end: ndx\n          } : _positioning.caret.call(inputmask, input),\n              forwardPosition,\n              c = String.fromCharCode(k);\n          maskset.writeOutBuffer = !0;\n\n          var valResult = _validation.isValid.call(inputmask, pos, c, strict, void 0, void 0, void 0, checkval);\n\n          if (!1 !== valResult && (_positioning.resetMaskSet.call(inputmask, !0), forwardPosition = void 0 !== valResult.caret ? valResult.caret : _positioning.seekNext.call(inputmask, valResult.pos.begin ? valResult.pos.begin : valResult.pos), maskset.p = forwardPosition), forwardPosition = opts.numericInput && void 0 === valResult.caret ? _positioning.seekPrevious.call(inputmask, forwardPosition) : forwardPosition, !1 !== writeOut && (setTimeout(function () {\n            opts.onKeyValidation.call(input, k, valResult);\n          }, 0), maskset.writeOutBuffer && !1 !== valResult)) {\n            var buffer = _positioning.getBuffer.call(inputmask);\n\n            (0, _inputHandling.writeBuffer)(input, buffer, forwardPosition, e, !0 !== checkval);\n          }\n\n          if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition), valResult;\n        }\n      },\n      keyupEvent: function keyupEvent(e) {\n        var inputmask = this.inputmask;\n        !inputmask.isComposing || e.keyCode !== _keycode[\"default\"].KEY_229 && e.keyCode !== _keycode[\"default\"].ENTER || inputmask.$el.trigger(\"input\");\n      },\n      pasteEvent: function pasteEvent(e) {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts,\n            input = this,\n            inputValue = inputmask._valueGet(!0),\n            caretPos = _positioning.caret.call(inputmask, this),\n            tempValue;\n\n        inputmask.isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);\n        var valueBeforeCaret = inputValue.substr(0, caretPos.begin),\n            valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\n        if (valueBeforeCaret == (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).slice(0, caretPos.begin).join(\"\") && (valueBeforeCaret = \"\"), valueAfterCaret == (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).slice(caretPos.end).join(\"\") && (valueAfterCaret = \"\"), window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret;else {\n          if (!e.clipboardData || !e.clipboardData.getData) return !0;\n          inputValue = valueBeforeCaret + e.clipboardData.getData(\"text/plain\") + valueAfterCaret;\n        }\n        var pasteValue = inputValue;\n\n        if (\"function\" == typeof opts.onBeforePaste) {\n          if (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts), !1 === pasteValue) return e.preventDefault();\n          pasteValue = pasteValue || inputValue;\n        }\n\n        return (0, _inputHandling.checkVal)(this, !0, !1, pasteValue.toString().split(\"\"), e), e.preventDefault();\n      },\n      inputFallBackEvent: function inputFallBackEvent(e) {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts,\n            $ = inputmask.dependencyLib;\n\n        function ieMobileHandler(input, inputValue, caretPos) {\n          if (_environment.iemobile) {\n            var inputChar = inputValue.replace(_positioning.getBuffer.call(inputmask).join(\"\"), \"\");\n\n            if (1 === inputChar.length) {\n              var iv = inputValue.split(\"\");\n              iv.splice(caretPos.begin, 0, inputChar), inputValue = iv.join(\"\");\n            }\n          }\n\n          return inputValue;\n        }\n\n        function analyseChanges(inputValue, buffer, caretPos) {\n          for (var frontPart = inputValue.substr(0, caretPos.begin).split(\"\"), backPart = inputValue.substr(caretPos.begin).split(\"\"), frontBufferPart = buffer.substr(0, caretPos.begin).split(\"\"), backBufferPart = buffer.substr(caretPos.begin).split(\"\"), fpl = frontPart.length >= frontBufferPart.length ? frontPart.length : frontBufferPart.length, bpl = backPart.length >= backBufferPart.length ? backPart.length : backBufferPart.length, bl, i, action = \"\", data = [], marker = \"~\", placeholder; frontPart.length < fpl;) {\n            frontPart.push(\"~\");\n          }\n\n          for (; frontBufferPart.length < fpl;) {\n            frontBufferPart.push(\"~\");\n          }\n\n          for (; backPart.length < bpl;) {\n            backPart.unshift(\"~\");\n          }\n\n          for (; backBufferPart.length < bpl;) {\n            backBufferPart.unshift(\"~\");\n          }\n\n          var newBuffer = frontPart.concat(backPart),\n              oldBuffer = frontBufferPart.concat(backBufferPart);\n\n          for (i = 0, bl = newBuffer.length; i < bl; i++) {\n            switch (placeholder = _validationTests.getPlaceholder.call(inputmask, _positioning.translatePosition.call(inputmask, i)), action) {\n              case \"insertText\":\n                oldBuffer[i - 1] === newBuffer[i] && caretPos.begin == newBuffer.length - 1 && data.push(newBuffer[i]), i = bl;\n                break;\n\n              case \"insertReplacementText\":\n                \"~\" === newBuffer[i] ? caretPos.end++ : i = bl;\n                break;\n\n              case \"deleteContentBackward\":\n                \"~\" === newBuffer[i] ? caretPos.end++ : i = bl;\n                break;\n\n              default:\n                newBuffer[i] !== oldBuffer[i] && (\"~\" !== newBuffer[i + 1] && newBuffer[i + 1] !== placeholder && void 0 !== newBuffer[i + 1] || (oldBuffer[i] !== placeholder || \"~\" !== oldBuffer[i + 1]) && \"~\" !== oldBuffer[i] ? \"~\" === oldBuffer[i + 1] && oldBuffer[i] === newBuffer[i + 1] ? (action = \"insertText\", data.push(newBuffer[i]), caretPos.begin--, caretPos.end--) : newBuffer[i] !== placeholder && \"~\" !== newBuffer[i] && (\"~\" === newBuffer[i + 1] || oldBuffer[i] !== newBuffer[i] && oldBuffer[i + 1] === newBuffer[i + 1]) ? (action = \"insertReplacementText\", data.push(newBuffer[i]), caretPos.begin--) : \"~\" === newBuffer[i] ? (action = \"deleteContentBackward\", !_positioning.isMask.call(inputmask, _positioning.translatePosition.call(inputmask, i), !0) && oldBuffer[i] !== opts.radixPoint || caretPos.end++) : i = bl : (action = \"insertText\", data.push(newBuffer[i]), caretPos.begin--, caretPos.end--));\n                break;\n            }\n          }\n\n          return {\n            action: action,\n            data: data,\n            caret: caretPos\n          };\n        }\n\n        var input = this,\n            inputValue = input.inputmask._valueGet(!0),\n            buffer = (inputmask.isRTL ? _positioning.getBuffer.call(inputmask).slice().reverse() : _positioning.getBuffer.call(inputmask)).join(\"\"),\n            caretPos = _positioning.caret.call(inputmask, input, void 0, void 0, !0);\n\n        if (buffer !== inputValue) {\n          inputValue = ieMobileHandler(input, inputValue, caretPos);\n          var changes = analyseChanges(inputValue, buffer, caretPos);\n\n          switch ((input.inputmask.shadowRoot || document).activeElement !== input && input.focus(), (0, _inputHandling.writeBuffer)(input, _positioning.getBuffer.call(inputmask)), _positioning.caret.call(inputmask, input, caretPos.begin, caretPos.end, !0), changes.action) {\n            case \"insertText\":\n            case \"insertReplacementText\":\n              changes.data.forEach(function (entry, ndx) {\n                var keypress = new $.Event(\"keypress\");\n                keypress.which = entry.charCodeAt(0), inputmask.ignorable = !1, EventHandlers.keypressEvent.call(input, keypress);\n              }), setTimeout(function () {\n                inputmask.$el.trigger(\"keyup\");\n              }, 0);\n              break;\n\n            case \"deleteContentBackward\":\n              var keydown = new $.Event(\"keydown\");\n              keydown.keyCode = _keycode[\"default\"].BACKSPACE, EventHandlers.keydownEvent.call(input, keydown);\n              break;\n\n            default:\n              (0, _inputHandling.applyInputValue)(input, inputValue);\n              break;\n          }\n\n          e.preventDefault();\n        }\n      },\n      compositionendEvent: function compositionendEvent(e) {\n        var inputmask = this.inputmask;\n        inputmask.isComposing = !1, inputmask.$el.trigger(\"input\");\n      },\n      setValueEvent: function setValueEvent(e, argument_1, argument_2) {\n        var inputmask = this.inputmask,\n            input = this,\n            value = e && e.detail ? e.detail[0] : argument_1;\n        void 0 === value && (value = this.inputmask._valueGet(!0)), (0, _inputHandling.applyInputValue)(this, value), (e.detail && void 0 !== e.detail[1] || void 0 !== argument_2) && _positioning.caret.call(inputmask, this, e.detail ? e.detail[1] : argument_2);\n      },\n      focusEvent: function focusEvent(e) {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts,\n            input = this,\n            nptValue = this.inputmask._valueGet();\n\n        opts.showMaskOnFocus && nptValue !== _positioning.getBuffer.call(inputmask).join(\"\") && (0, _inputHandling.writeBuffer)(this, _positioning.getBuffer.call(inputmask), _positioning.seekNext.call(inputmask, _positioning.getLastValidPosition.call(inputmask))), !0 !== opts.positionCaretOnTab || !1 !== inputmask.mouseEnter || _validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && -1 !== _positioning.getLastValidPosition.call(inputmask) || EventHandlers.clickEvent.apply(this, [e, !0]), inputmask.undoValue = _positioning.getBuffer.call(inputmask).join(\"\");\n      },\n      invalidEvent: function invalidEvent(e) {\n        this.inputmask.validationEvent = !0;\n      },\n      mouseleaveEvent: function mouseleaveEvent() {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts,\n            input = this;\n        inputmask.mouseEnter = !1, opts.clearMaskOnLostFocus && (this.inputmask.shadowRoot || document).activeElement !== this && (0, _inputHandling.HandleNativePlaceholder)(this, inputmask.originalPlaceholder);\n      },\n      clickEvent: function clickEvent(e, tabbed) {\n        var inputmask = this.inputmask,\n            input = this;\n\n        if ((this.inputmask.shadowRoot || document).activeElement === this) {\n          var newCaretPosition = _positioning.determineNewCaretPosition.call(inputmask, _positioning.caret.call(inputmask, this), tabbed);\n\n          void 0 !== newCaretPosition && _positioning.caret.call(inputmask, this, newCaretPosition);\n        }\n      },\n      cutEvent: function cutEvent(e) {\n        var inputmask = this.inputmask,\n            maskset = inputmask.maskset,\n            input = this,\n            pos = _positioning.caret.call(inputmask, this),\n            clipboardData = window.clipboardData || e.clipboardData,\n            clipData = inputmask.isRTL ? _positioning.getBuffer.call(inputmask).slice(pos.end, pos.begin) : _positioning.getBuffer.call(inputmask).slice(pos.begin, pos.end);\n\n        clipboardData.setData(\"text\", inputmask.isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\")), document.execCommand && document.execCommand(\"copy\"), _validation.handleRemove.call(inputmask, this, _keycode[\"default\"].DELETE, pos), (0, _inputHandling.writeBuffer)(this, _positioning.getBuffer.call(inputmask), maskset.p, e, inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join(\"\"));\n      },\n      blurEvent: function blurEvent(e) {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts,\n            $ = inputmask.dependencyLib,\n            $input = $(this),\n            input = this;\n\n        if (this.inputmask) {\n          (0, _inputHandling.HandleNativePlaceholder)(this, inputmask.originalPlaceholder);\n\n          var nptValue = this.inputmask._valueGet(),\n              buffer = _positioning.getBuffer.call(inputmask).slice();\n\n          \"\" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === _positioning.getLastValidPosition.call(inputmask) && nptValue === _positioning.getBufferTemplate.call(inputmask).join(\"\") ? buffer = [] : _inputHandling.clearOptionalTail.call(inputmask, buffer)), !1 === _validation.isComplete.call(inputmask, buffer) && (setTimeout(function () {\n            $input.trigger(\"incomplete\");\n          }, 0), opts.clearIncomplete && (_positioning.resetMaskSet.call(inputmask), buffer = opts.clearMaskOnLostFocus ? [] : _positioning.getBufferTemplate.call(inputmask).slice())), (0, _inputHandling.writeBuffer)(this, buffer, void 0, e)), inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join(\"\") && (inputmask.undoValue = _positioning.getBuffer.call(inputmask).join(\"\"), $input.trigger(\"change\"));\n        }\n      },\n      mouseenterEvent: function mouseenterEvent() {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts,\n            input = this;\n        inputmask.mouseEnter = !0, (this.inputmask.shadowRoot || document).activeElement !== this && (null == inputmask.originalPlaceholder && this.placeholder !== inputmask.originalPlaceholder && (inputmask.originalPlaceholder = this.placeholder), opts.showMaskOnHover && (0, _inputHandling.HandleNativePlaceholder)(this, (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).join(\"\")));\n      },\n      submitEvent: function submitEvent() {\n        var inputmask = this.inputmask,\n            opts = inputmask.opts;\n        inputmask.undoValue !== _positioning.getBuffer.call(inputmask).join(\"\") && inputmask.$el.trigger(\"change\"), opts.clearMaskOnLostFocus && -1 === _positioning.getLastValidPosition.call(inputmask) && inputmask._valueGet && inputmask._valueGet() === _positioning.getBufferTemplate.call(inputmask).join(\"\") && inputmask._valueSet(\"\"), opts.clearIncomplete && !1 === _validation.isComplete.call(inputmask, _positioning.getBuffer.call(inputmask)) && inputmask._valueSet(\"\"), opts.removeMaskOnSubmit && (inputmask._valueSet(inputmask.unmaskedvalue(), !0), setTimeout(function () {\n          (0, _inputHandling.writeBuffer)(inputmask.el, _positioning.getBuffer.call(inputmask));\n        }, 0));\n      },\n      resetEvent: function resetEvent() {\n        var inputmask = this.inputmask;\n        inputmask.refreshValue = !0, setTimeout(function () {\n          (0, _inputHandling.applyInputValue)(inputmask.el, inputmask._valueGet(!0));\n        }, 0);\n      }\n    };\n    exports.EventHandlers = EventHandlers;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.iphone = exports.iemobile = exports.mobile = exports.ie = exports.ua = void 0;\n    var ua = window.navigator && window.navigator.userAgent || \"\",\n        ie = 0 < ua.indexOf(\"MSIE \") || 0 < ua.indexOf(\"Trident/\"),\n        mobile = (\"ontouchstart\" in window),\n        iemobile = /iemobile/i.test(ua),\n        iphone = /iphone/i.test(ua) && !iemobile;\n    exports.iphone = iphone, exports.iemobile = iemobile, exports.mobile = mobile, exports.ie = ie, exports.ua = ua;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = void 0;\n\n    var _extend = _interopRequireDefault(__webpack_require__(13)),\n        _window = _interopRequireDefault(__webpack_require__(6)),\n        _data = _interopRequireDefault(__webpack_require__(17)),\n        _events = __webpack_require__(18);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var document = _window[\"default\"].document;\n\n    function DependencyLib(elem) {\n      return elem instanceof DependencyLib ? elem : this instanceof DependencyLib ? void (null != elem && elem !== _window[\"default\"] && (this[0] = elem.nodeName ? elem : void 0 !== elem[0] && elem[0].nodeName ? elem[0] : document.querySelector(elem), void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new DependencyLib(elem);\n    }\n\n    DependencyLib.prototype = {\n      on: _events.on,\n      off: _events.off,\n      trigger: _events.trigger\n    }, DependencyLib.extend = _extend[\"default\"], DependencyLib.data = _data[\"default\"], DependencyLib.Event = _events.Event;\n    var _default = DependencyLib;\n    exports[\"default\"] = _default;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function _typeof(obj) {\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == _typeof2(Symbol.iterator) ? function _typeof(obj) {\n        return _typeof2(obj);\n      } : function _typeof(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      }, _typeof(obj);\n    }\n\n    \"function\" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = \"object\" === _typeof(\"test\".__proto__) ? function (object) {\n      return object.__proto__;\n    } : function (object) {\n      return object.constructor.prototype;\n    });\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.mask = mask, __webpack_require__(10);\n\n    var _keycode = _interopRequireDefault(__webpack_require__(0)),\n        _positioning = __webpack_require__(2),\n        _inputHandling = __webpack_require__(5),\n        _eventruler = __webpack_require__(12),\n        _environment = __webpack_require__(8),\n        _validation = __webpack_require__(4),\n        _eventhandlers = __webpack_require__(7);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    function mask() {\n      var inputmask = this,\n          opts = this.opts,\n          el = this.el,\n          $ = this.dependencyLib;\n\n      function isElementTypeSupported(input, opts) {\n        function patchValueProperty(npt) {\n          var valueGet, valueSet;\n\n          function patchValhook(type) {\n            if ($.valHooks && (void 0 === $.valHooks[type] || !0 !== $.valHooks[type].inputmaskpatch)) {\n              var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {\n                return elem.value;\n              },\n                  valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\n                return elem.value = value, elem;\n              };\n              $.valHooks[type] = {\n                get: function get(elem) {\n                  if (elem.inputmask) {\n                    if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();\n                    var result = valhookGet(elem);\n                    return -1 !== _positioning.getLastValidPosition.call(inputmask, void 0, void 0, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : \"\";\n                  }\n\n                  return valhookGet(elem);\n                },\n                set: function set(elem, value) {\n                  var result = valhookSet(elem, value);\n                  return elem.inputmask && (0, _inputHandling.applyInputValue)(elem, value), result;\n                },\n                inputmaskpatch: !0\n              };\n            }\n          }\n\n          function getter() {\n            return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== _positioning.getLastValidPosition.call(inputmask) || !0 !== opts.nullable ? (this.inputmask.shadowRoot || document.activeElement) === this && opts.clearMaskOnLostFocus ? (inputmask.isRTL ? _inputHandling.clearOptionalTail.call(inputmask, _positioning.getBuffer.call(inputmask).slice()).reverse() : _inputHandling.clearOptionalTail.call(inputmask, _positioning.getBuffer.call(inputmask).slice())).join(\"\") : valueGet.call(this) : \"\" : valueGet.call(this);\n          }\n\n          function setter(value) {\n            valueSet.call(this, value), this.inputmask && (0, _inputHandling.applyInputValue)(this, value);\n          }\n\n          function installNativeValueSetFallback(npt) {\n            _eventruler.EventRuler.on(npt, \"mouseenter\", function () {\n              var input = this,\n                  value = this.inputmask._valueGet(!0);\n\n              value !== (inputmask.isRTL ? _positioning.getBuffer.call(inputmask).reverse() : _positioning.getBuffer.call(inputmask)).join(\"\") && (0, _inputHandling.applyInputValue)(this, value);\n            });\n          }\n\n          if (!npt.inputmask.__valueGet) {\n            if (!0 !== opts.noValuePatching) {\n              if (Object.getOwnPropertyDescriptor) {\n                var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : void 0;\n                valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, valueSet = valueProperty.set, Object.defineProperty(npt, \"value\", {\n                  get: getter,\n                  set: setter,\n                  configurable: !0\n                })) : \"input\" !== npt.tagName.toLowerCase() && (valueGet = function valueGet() {\n                  return this.textContent;\n                }, valueSet = function valueSet(value) {\n                  this.textContent = value;\n                }, Object.defineProperty(npt, \"value\", {\n                  get: getter,\n                  set: setter,\n                  configurable: !0\n                }));\n              } else document.__lookupGetter__ && npt.__lookupGetter__(\"value\") && (valueGet = npt.__lookupGetter__(\"value\"), valueSet = npt.__lookupSetter__(\"value\"), npt.__defineGetter__(\"value\", getter), npt.__defineSetter__(\"value\", setter));\n\n              npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;\n            }\n\n            npt.inputmask._valueGet = function (overruleRTL) {\n              return inputmask.isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\n            }, npt.inputmask._valueSet = function (value, overruleRTL) {\n              valueSet.call(this.el, null == value ? \"\" : !0 !== overruleRTL && inputmask.isRTL ? value.split(\"\").reverse().join(\"\") : value);\n            }, void 0 === valueGet && (valueGet = function valueGet() {\n              return this.value;\n            }, valueSet = function valueSet(value) {\n              this.value = value;\n            }, patchValhook(npt.type), installNativeValueSetFallback(npt));\n          }\n        }\n\n        \"textarea\" !== input.tagName.toLowerCase() && opts.ignorables.push(_keycode[\"default\"].ENTER);\n        var elementType = input.getAttribute(\"type\"),\n            isSupported = \"input\" === input.tagName.toLowerCase() && opts.supportsInputType.includes(elementType) || input.isContentEditable || \"textarea\" === input.tagName.toLowerCase();\n        if (!isSupported) if (\"input\" === input.tagName.toLowerCase()) {\n          var el = document.createElement(\"input\");\n          el.setAttribute(\"type\", elementType), isSupported = \"text\" === el.type, el = null;\n        } else isSupported = \"partial\";\n        return !1 !== isSupported ? patchValueProperty(input) : input.inputmask = void 0, isSupported;\n      }\n\n      _eventruler.EventRuler.off(el);\n\n      var isSupported = isElementTypeSupported(el, opts);\n\n      if (!1 !== isSupported) {\n        inputmask.originalPlaceholder = el.placeholder, inputmask.maxLength = void 0 !== el ? el.maxLength : void 0, -1 === inputmask.maxLength && (inputmask.maxLength = void 0), \"inputMode\" in el && null === el.getAttribute(\"inputmode\") && (el.inputMode = opts.inputmode, el.setAttribute(\"inputmode\", opts.inputmode)), !0 === isSupported && (opts.showMaskOnFocus = opts.showMaskOnFocus && -1 === [\"cc-number\", \"cc-exp\"].indexOf(el.autocomplete), _environment.iphone && (opts.insertModeVisual = !1), _eventruler.EventRuler.on(el, \"submit\", _eventhandlers.EventHandlers.submitEvent), _eventruler.EventRuler.on(el, \"reset\", _eventhandlers.EventHandlers.resetEvent), _eventruler.EventRuler.on(el, \"blur\", _eventhandlers.EventHandlers.blurEvent), _eventruler.EventRuler.on(el, \"focus\", _eventhandlers.EventHandlers.focusEvent), _eventruler.EventRuler.on(el, \"invalid\", _eventhandlers.EventHandlers.invalidEvent), _eventruler.EventRuler.on(el, \"click\", _eventhandlers.EventHandlers.clickEvent), _eventruler.EventRuler.on(el, \"mouseleave\", _eventhandlers.EventHandlers.mouseleaveEvent), _eventruler.EventRuler.on(el, \"mouseenter\", _eventhandlers.EventHandlers.mouseenterEvent), _eventruler.EventRuler.on(el, \"paste\", _eventhandlers.EventHandlers.pasteEvent), _eventruler.EventRuler.on(el, \"cut\", _eventhandlers.EventHandlers.cutEvent), _eventruler.EventRuler.on(el, \"complete\", opts.oncomplete), _eventruler.EventRuler.on(el, \"incomplete\", opts.onincomplete), _eventruler.EventRuler.on(el, \"cleared\", opts.oncleared), !0 !== opts.inputEventOnly && (_eventruler.EventRuler.on(el, \"keydown\", _eventhandlers.EventHandlers.keydownEvent), _eventruler.EventRuler.on(el, \"keypress\", _eventhandlers.EventHandlers.keypressEvent), _eventruler.EventRuler.on(el, \"keyup\", _eventhandlers.EventHandlers.keyupEvent)), (_environment.mobile || opts.inputEventOnly) && el.removeAttribute(\"maxLength\"), _eventruler.EventRuler.on(el, \"input\", _eventhandlers.EventHandlers.inputFallBackEvent), _eventruler.EventRuler.on(el, \"compositionend\", _eventhandlers.EventHandlers.compositionendEvent)), _eventruler.EventRuler.on(el, \"setvalue\", _eventhandlers.EventHandlers.setValueEvent), inputmask.undoValue = _positioning.getBufferTemplate.call(inputmask).join(\"\");\n        var activeElement = (el.inputmask.shadowRoot || document).activeElement;\n\n        if (\"\" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || activeElement === el) {\n          (0, _inputHandling.applyInputValue)(el, el.inputmask._valueGet(!0), opts);\n\n          var buffer = _positioning.getBuffer.call(inputmask).slice();\n\n          !1 === _validation.isComplete.call(inputmask, buffer) && opts.clearIncomplete && _positioning.resetMaskSet.call(inputmask), opts.clearMaskOnLostFocus && activeElement !== el && (-1 === _positioning.getLastValidPosition.call(inputmask) ? buffer = [] : _inputHandling.clearOptionalTail.call(inputmask, buffer)), (!1 === opts.clearMaskOnLostFocus || opts.showMaskOnFocus && activeElement === el || \"\" !== el.inputmask._valueGet(!0)) && (0, _inputHandling.writeBuffer)(el, buffer), activeElement === el && _positioning.caret.call(inputmask, el, _positioning.seekNext.call(inputmask, _positioning.getLastValidPosition.call(inputmask)));\n        }\n      }\n    }\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.EventRuler = void 0;\n\n    var _inputmask = _interopRequireDefault(__webpack_require__(1)),\n        _keycode = _interopRequireDefault(__webpack_require__(0)),\n        _positioning = __webpack_require__(2),\n        _inputHandling = __webpack_require__(5);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var EventRuler = {\n      on: function on(input, eventName, eventHandler) {\n        var $ = input.inputmask.dependencyLib,\n            ev = function ev(e) {\n          e.originalEvent && (e = e.originalEvent || e, arguments[0] = e);\n          var that = this,\n              args,\n              inputmask = that.inputmask,\n              opts = inputmask ? inputmask.opts : void 0,\n              $ = inputmask.dependencyLib;\n\n          if (void 0 === inputmask && \"FORM\" !== this.nodeName) {\n            var imOpts = $.data(that, \"_inputmask_opts\");\n            $(that).off(), imOpts && new _inputmask[\"default\"](imOpts).mask(that);\n          } else {\n            if (\"setvalue\" === e.type || \"FORM\" === this.nodeName || !(that.disabled || that.readOnly && !(\"keydown\" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === _keycode[\"default\"].TAB))) {\n              switch (e.type) {\n                case \"input\":\n                  if (!0 === inputmask.skipInputEvent || e.inputType && \"insertCompositionText\" === e.inputType) return inputmask.skipInputEvent = !1, e.preventDefault();\n                  break;\n\n                case \"keydown\":\n                  inputmask.skipKeyPressEvent = !1, inputmask.skipInputEvent = inputmask.isComposing = e.keyCode === _keycode[\"default\"].KEY_229;\n                  break;\n\n                case \"keyup\":\n                case \"compositionend\":\n                  inputmask.isComposing && (inputmask.skipInputEvent = !1);\n                  break;\n\n                case \"keypress\":\n                  if (!0 === inputmask.skipKeyPressEvent) return e.preventDefault();\n                  inputmask.skipKeyPressEvent = !0;\n                  break;\n\n                case \"click\":\n                case \"focus\":\n                  return inputmask.validationEvent ? (inputmask.validationEvent = !1, input.blur(), (0, _inputHandling.HandleNativePlaceholder)(input, (inputmask.isRTL ? _positioning.getBufferTemplate.call(inputmask).slice().reverse() : _positioning.getBufferTemplate.call(inputmask)).join(\"\")), setTimeout(function () {\n                    input.focus();\n                  }, 3e3)) : (args = arguments, setTimeout(function () {\n                    input.inputmask && eventHandler.apply(that, args);\n                  }, 0)), !1;\n              }\n\n              var returnVal = eventHandler.apply(that, arguments);\n              return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;\n            }\n\n            e.preventDefault();\n          }\n        };\n\n        input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), [\"submit\", \"reset\"].includes(eventName) ? null !== input.form && $(input.form).on(eventName, ev.bind(input)) : $(input).on(eventName, ev);\n      },\n      off: function off(input, event) {\n        if (input.inputmask && input.inputmask.events) {\n          var $ = input.inputmask.dependencyLib,\n              events = input.inputmask.events;\n\n          for (var eventName in event && (events = [], events[event] = input.inputmask.events[event]), events) {\n            for (var evArr = events[eventName]; 0 < evArr.length;) {\n              var ev = evArr.pop();\n              [\"submit\", \"reset\"].includes(eventName) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);\n            }\n\n            delete input.inputmask.events[eventName];\n          }\n        }\n      }\n    };\n    exports.EventRuler = EventRuler;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function _typeof(obj) {\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == _typeof2(Symbol.iterator) ? function _typeof(obj) {\n        return _typeof2(obj);\n      } : function _typeof(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      }, _typeof(obj);\n    }\n\n    function extend() {\n      var options,\n          name,\n          src,\n          copy,\n          copyIsArray,\n          clone,\n          target = arguments[0] || {},\n          i = 1,\n          length = arguments.length,\n          deep = !1;\n\n      for (\"boolean\" == typeof target && (deep = target, target = arguments[i] || {}, i++), \"object\" !== _typeof(target) && \"function\" != typeof target && (target = {}); i < length; i++) {\n        if (null != (options = arguments[i])) for (name in options) {\n          src = target[name], copy = options[name], target !== copy && (deep && copy && (\"[object Object]\" === Object.prototype.toString.call(copy) || (copyIsArray = Array.isArray(copy))) ? (clone = copyIsArray ? (copyIsArray = !1, src && Array.isArray(src) ? src : []) : src && \"[object Object]\" === Object.prototype.toString.call(src) ? src : {}, target[name] = extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));\n        }\n      }\n\n      return target;\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = extend;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = _default;\n    var escapeRegexRegex = new RegExp(\"(\\\\\" + [\"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\"].join(\"|\\\\\") + \")\", \"gim\");\n\n    function _default(str) {\n      return str.replace(escapeRegexRegex, \"\\\\$1\");\n    }\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = void 0, __webpack_require__(16), __webpack_require__(22), __webpack_require__(23), __webpack_require__(24);\n\n    var _inputmask2 = _interopRequireDefault(__webpack_require__(1));\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var _default = _inputmask2[\"default\"];\n    exports[\"default\"] = _default;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var _inputmask = _interopRequireDefault(__webpack_require__(1));\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    _inputmask[\"default\"].extendDefinitions({\n      A: {\n        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\xC0-\\xFF\\xB5]\",\n        casing: \"upper\"\n      },\n      \"&\": {\n        validator: \"[0-9A-Za-z\\u0410-\\u044F\\u0401\\u0451\\xC0-\\xFF\\xB5]\",\n        casing: \"upper\"\n      },\n      \"#\": {\n        validator: \"[0-9A-Fa-f]\",\n        casing: \"upper\"\n      }\n    });\n\n    var ipValidatorRegex = new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\");\n\n    function ipValidator(chrs, maskset, pos, strict, opts) {\n      return chrs = -1 < pos - 1 && \".\" !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, -1 < pos - 2 && \".\" !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : \"0\" + chrs) : \"00\" + chrs, ipValidatorRegex.test(chrs);\n    }\n\n    _inputmask[\"default\"].extendAliases({\n      cssunit: {\n        regex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\n      },\n      url: {\n        regex: \"(https?|ftp)://.*\",\n        autoUnmask: !1,\n        keepStatic: !1,\n        tabThrough: !0\n      },\n      ip: {\n        mask: \"i[i[i]].j[j[j]].k[k[k]].l[l[l]]\",\n        definitions: {\n          i: {\n            validator: ipValidator\n          },\n          j: {\n            validator: ipValidator\n          },\n          k: {\n            validator: ipValidator\n          },\n          l: {\n            validator: ipValidator\n          }\n        },\n        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n          return maskedValue;\n        },\n        inputmode: \"numeric\"\n      },\n      email: {\n        mask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\n        greedy: !1,\n        casing: \"lower\",\n        onBeforePaste: function onBeforePaste(pastedValue, opts) {\n          return pastedValue = pastedValue.toLowerCase(), pastedValue.replace(\"mailto:\", \"\");\n        },\n        definitions: {\n          \"*\": {\n            validator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\xC0-\\xFF\\xB5!#$%&'*+/=?^_`{|}~-]\"\n          },\n          \"-\": {\n            validator: \"[0-9A-Za-z-]\"\n          }\n        },\n        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n          return maskedValue;\n        },\n        inputmode: \"email\"\n      },\n      mac: {\n        mask: \"##:##:##:##:##:##\"\n      },\n      vin: {\n        mask: \"V{13}9{4}\",\n        definitions: {\n          V: {\n            validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\n            casing: \"upper\"\n          }\n        },\n        clearIncomplete: !0,\n        autoUnmask: !0\n      },\n      ssn: {\n        mask: \"999-99-9999\",\n        postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {\n          return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(buffer.join(\"\"));\n        }\n      }\n    });\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function _default(owner, key, value) {\n      if (void 0 === value) return owner.__data ? owner.__data[key] : null;\n      owner.__data = owner.__data || {}, owner.__data[key] = value;\n    }\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = _default;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.on = on, exports.off = off, exports.trigger = trigger, exports.Event = void 0;\n\n    var _extend = _interopRequireDefault(__webpack_require__(13)),\n        _window = _interopRequireDefault(__webpack_require__(6)),\n        _inputmask = _interopRequireDefault(__webpack_require__(9)),\n        Event;\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    function isValidElement(elem) {\n      return elem instanceof Element;\n    }\n\n    function on(events, handler) {\n      function addEvent(ev, namespace) {\n        elem.addEventListener ? elem.addEventListener(ev, handler, !1) : elem.attachEvent && elem.attachEvent(\"on\" + ev, handler), eventRegistry[ev] = eventRegistry[ev] || {}, eventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [], eventRegistry[ev][namespace].push(handler);\n      }\n\n      if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = events.split(\" \"), endx = 0; endx < _events.length; endx++) {\n        var nsEvent = _events[endx].split(\".\"),\n            ev = nsEvent[0],\n            namespace = nsEvent[1] || \"global\";\n\n        addEvent(ev, namespace);\n      }\n      return this;\n    }\n\n    function off(events, handler) {\n      var eventRegistry, elem;\n\n      function removeEvent(ev, namespace, handler) {\n        if (ev in eventRegistry == !0) if (elem.removeEventListener ? elem.removeEventListener(ev, handler, !1) : elem.detachEvent && elem.detachEvent(\"on\" + ev, handler), \"global\" === namespace) for (var nmsp in eventRegistry[ev]) {\n          eventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);\n        } else eventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);\n      }\n\n      function resolveNamespace(ev, namespace) {\n        var evts = [],\n            hndx,\n            hndL;\n        if (0 < ev.length) {\n          if (void 0 === handler) for (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) {\n            evts.push({\n              ev: ev,\n              namespace: namespace && 0 < namespace.length ? namespace : \"global\",\n              handler: eventRegistry[ev][namespace][hndx]\n            });\n          } else evts.push({\n            ev: ev,\n            namespace: namespace && 0 < namespace.length ? namespace : \"global\",\n            handler: handler\n          });\n        } else if (0 < namespace.length) for (var evNdx in eventRegistry) {\n          for (var nmsp in eventRegistry[evNdx]) {\n            if (nmsp === namespace) if (void 0 === handler) for (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) {\n              evts.push({\n                ev: evNdx,\n                namespace: nmsp,\n                handler: eventRegistry[evNdx][nmsp][hndx]\n              });\n            } else evts.push({\n              ev: evNdx,\n              namespace: nmsp,\n              handler: handler\n            });\n          }\n        }\n        return evts;\n      }\n\n      if (isValidElement(this[0])) {\n        eventRegistry = this[0].eventRegistry, elem = this[0];\n\n        for (var _events = events.split(\" \"), endx = 0; endx < _events.length; endx++) {\n          for (var nsEvent = _events[endx].split(\".\"), offEvents = resolveNamespace(nsEvent[0], nsEvent[1]), i = 0, offEventsL = offEvents.length; i < offEventsL; i++) {\n            removeEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);\n          }\n        }\n      }\n\n      return this;\n    }\n\n    function trigger(events) {\n      if (isValidElement(this[0])) for (var eventRegistry = this[0].eventRegistry, elem = this[0], _events = \"string\" == typeof events ? events.split(\" \") : [events.type], endx = 0; endx < _events.length; endx++) {\n        var nsEvent = _events[endx].split(\".\"),\n            ev = nsEvent[0],\n            namespace = nsEvent[1] || \"global\";\n\n        if (void 0 !== document && \"global\" === namespace) {\n          var evnt,\n              i,\n              params = {\n            bubbles: !0,\n            cancelable: !0,\n            detail: arguments[1]\n          };\n\n          if (document.createEvent) {\n            try {\n              evnt = new CustomEvent(ev, params);\n            } catch (e) {\n              evnt = document.createEvent(\"CustomEvent\"), evnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);\n            }\n\n            events.type && (0, _extend[\"default\"])(evnt, events), elem.dispatchEvent(evnt);\n          } else evnt = document.createEventObject(), evnt.eventType = ev, evnt.detail = arguments[1], events.type && (0, _extend[\"default\"])(evnt, events), elem.fireEvent(\"on\" + evnt.eventType, evnt);\n        } else if (void 0 !== eventRegistry[ev]) if (arguments[0] = arguments[0].type ? arguments[0] : _inputmask[\"default\"].Event(arguments[0]), arguments[0].detail = arguments.slice(1), \"global\" === namespace) for (var nmsp in eventRegistry[ev]) {\n          for (i = 0; i < eventRegistry[ev][nmsp].length; i++) {\n            eventRegistry[ev][nmsp][i].apply(elem, arguments);\n          }\n        } else for (i = 0; i < eventRegistry[ev][namespace].length; i++) {\n          eventRegistry[ev][namespace][i].apply(elem, arguments);\n        }\n      }\n      return this;\n    }\n\n    exports.Event = Event, \"function\" == typeof _window[\"default\"].CustomEvent ? exports.Event = Event = _window[\"default\"].CustomEvent : (exports.Event = Event = function Event(event, params) {\n      params = params || {\n        bubbles: !1,\n        cancelable: !1,\n        detail: void 0\n      };\n      var evt = document.createEvent(\"CustomEvent\");\n      return evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail), evt;\n    }, Event.prototype = _window[\"default\"].Event.prototype);\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports.generateMaskSet = generateMaskSet, exports.analyseMask = analyseMask;\n\n    var _inputmask = _interopRequireDefault(__webpack_require__(9));\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    function generateMaskSet(opts, nocache) {\n      var ms;\n\n      function generateMask(mask, metadata, opts) {\n        var regexMask = !1,\n            masksetDefinition,\n            maskdefKey;\n\n        if (null !== mask && \"\" !== mask || (regexMask = null !== opts.regex, mask = regexMask ? (mask = opts.regex, mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\")) : (regexMask = !0, \".*\")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = \"\"), 0 < opts.repeat || \"*\" === opts.repeat || \"+\" === opts.repeat) {\n          var repeatStart = \"*\" === opts.repeat ? 0 : \"+\" === opts.repeat ? 1 : opts.repeat;\n          mask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\n        }\n\n        return maskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask, !1 !== opts.keepStatic && (maskdefKey = \"ks_\" + maskdefKey), void 0 === Inputmask.prototype.masksCache[maskdefKey] || !0 === nocache ? (masksetDefinition = {\n          mask: mask,\n          maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),\n          validPositions: {},\n          _buffer: void 0,\n          buffer: void 0,\n          tests: {},\n          excludes: {},\n          metadata: metadata,\n          maskLength: void 0,\n          jitOffset: {}\n        }, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition, masksetDefinition = _inputmask[\"default\"].extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = _inputmask[\"default\"].extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]), masksetDefinition;\n      }\n\n      if (\"function\" == typeof opts.mask && (opts.mask = opts.mask(opts)), Array.isArray(opts.mask)) {\n        if (1 < opts.mask.length) {\n          null === opts.keepStatic && (opts.keepStatic = !0);\n          var altMask = opts.groupmarker[0];\n          return (opts.isRTL ? opts.mask.reverse() : opts.mask).forEach(function (msk) {\n            1 < altMask.length && (altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]), void 0 !== msk.mask && \"function\" != typeof msk.mask ? altMask += msk.mask : altMask += msk;\n          }), altMask += opts.groupmarker[1], generateMask(altMask, opts.mask, opts);\n        }\n\n        opts.mask = opts.mask.pop();\n      }\n\n      return null === opts.keepStatic && (opts.keepStatic = !1), ms = opts.mask && void 0 !== opts.mask.mask && \"function\" != typeof opts.mask.mask ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts), ms;\n    }\n\n    function analyseMask(mask, regexMask, opts) {\n      var tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g,\n          regexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\n          escaped = !1,\n          currentToken = new MaskToken(),\n          match,\n          m,\n          openenings = [],\n          maskTokens = [],\n          openingToken,\n          currentOpeningToken,\n          alternator,\n          lastMatch,\n          closeRegexGroup = !1;\n\n      function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\n        this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1, this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, this.quantifier = {\n          min: 1,\n          max: 1\n        };\n      }\n\n      function insertTestDefinition(mtoken, element, position) {\n        position = void 0 !== position ? position : mtoken.matches.length;\n        var prevMatch = mtoken.matches[position - 1];\n        if (regexMask) 0 === element.indexOf(\"[\") || escaped && /\\\\d|\\\\s|\\\\w]/i.test(element) || \".\" === element ? mtoken.matches.splice(position++, 0, {\n          fn: new RegExp(element, opts.casing ? \"i\" : \"\"),\n          \"static\": !1,\n          optionality: !1,\n          newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== element,\n          casing: null,\n          def: element,\n          placeholder: void 0,\n          nativeDef: element\n        }) : (escaped && (element = element[element.length - 1]), element.split(\"\").forEach(function (lmnt, ndx) {\n          prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {\n            fn: /[a-z]/i.test(opts.staticDefinitionSymbol || lmnt) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || lmnt) + \"]\", opts.casing ? \"i\" : \"\") : null,\n            \"static\": !0,\n            optionality: !1,\n            newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== lmnt && !0 !== prevMatch[\"static\"],\n            casing: null,\n            def: opts.staticDefinitionSymbol || lmnt,\n            placeholder: void 0 !== opts.staticDefinitionSymbol ? lmnt : void 0,\n            nativeDef: (escaped ? \"'\" : \"\") + lmnt\n          });\n        })), escaped = !1;else {\n          var maskdef = opts.definitions && opts.definitions[element] || opts.usePrototypeDefinitions && Inputmask.prototype.definitions[element];\n          maskdef && !escaped ? mtoken.matches.splice(position++, 0, {\n            fn: maskdef.validator ? \"string\" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function () {\n              this.test = maskdef.validator;\n            }() : new RegExp(\".\"),\n            \"static\": maskdef[\"static\"] || !1,\n            optionality: !1,\n            newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\n            casing: maskdef.casing,\n            def: maskdef.definitionSymbol || element,\n            placeholder: maskdef.placeholder,\n            nativeDef: element,\n            generated: maskdef.generated\n          }) : (mtoken.matches.splice(position++, 0, {\n            fn: /[a-z]/i.test(opts.staticDefinitionSymbol || element) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || element) + \"]\", opts.casing ? \"i\" : \"\") : null,\n            \"static\": !0,\n            optionality: !1,\n            newBlockMarker: void 0 === prevMatch ? \"master\" : prevMatch.def !== element && !0 !== prevMatch[\"static\"],\n            casing: null,\n            def: opts.staticDefinitionSymbol || element,\n            placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0,\n            nativeDef: (escaped ? \"'\" : \"\") + element\n          }), escaped = !1);\n        }\n      }\n\n      function verifyGroupMarker(maskToken) {\n        maskToken && maskToken.matches && maskToken.matches.forEach(function (token, ndx) {\n          var nextToken = maskToken.matches[ndx + 1];\n          (void 0 === nextToken || void 0 === nextToken.matches || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1, regexMask || (insertTestDefinition(token, opts.groupmarker[0], 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker[1]))), verifyGroupMarker(token);\n        });\n      }\n\n      function defaultCase() {\n        if (0 < openenings.length) {\n          if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m), currentOpeningToken.isAlternator) {\n            alternator = openenings.pop();\n\n            for (var mndx = 0; mndx < alternator.matches.length; mndx++) {\n              alternator.matches[mndx].isGroup && (alternator.matches[mndx].isGroup = !1);\n            }\n\n            0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);\n          }\n        } else insertTestDefinition(currentToken, m);\n      }\n\n      function reverseTokens(maskToken) {\n        function reverseStatic(st) {\n          return st === opts.optionalmarker[0] ? st = opts.optionalmarker[1] : st === opts.optionalmarker[1] ? st = opts.optionalmarker[0] : st === opts.groupmarker[0] ? st = opts.groupmarker[1] : st === opts.groupmarker[1] && (st = opts.groupmarker[0]), st;\n        }\n\n        for (var match in maskToken.matches = maskToken.matches.reverse(), maskToken.matches) {\n          if (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) {\n            var intMatch = parseInt(match);\n\n            if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {\n              var qt = maskToken.matches[match];\n              maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);\n            }\n\n            void 0 !== maskToken.matches[match].matches ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = reverseStatic(maskToken.matches[match]);\n          }\n        }\n\n        return maskToken;\n      }\n\n      function groupify(matches) {\n        var groupToken = new MaskToken(!0);\n        return groupToken.openGroup = !1, groupToken.matches = matches, groupToken;\n      }\n\n      function closeGroup() {\n        if (openingToken = openenings.pop(), openingToken.openGroup = !1, void 0 !== openingToken) {\n          if (0 < openenings.length) {\n            if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken), currentOpeningToken.isAlternator) {\n              alternator = openenings.pop();\n\n              for (var mndx = 0; mndx < alternator.matches.length; mndx++) {\n                alternator.matches[mndx].isGroup = !1, alternator.matches[mndx].alternatorGroup = !1;\n              }\n\n              0 < openenings.length ? (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);\n            }\n          } else currentToken.matches.push(openingToken);\n        } else defaultCase();\n      }\n\n      function groupQuantifier(matches) {\n        var lastMatch = matches.pop();\n        return lastMatch.isQuantifier && (lastMatch = groupify([matches.pop(), lastMatch])), lastMatch;\n      }\n\n      for (regexMask && (opts.optionalmarker[0] = void 0, opts.optionalmarker[1] = void 0); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask);) {\n        if (m = match[0], regexMask) switch (m.charAt(0)) {\n          case \"?\":\n            m = \"{0,1}\";\n            break;\n\n          case \"+\":\n          case \"*\":\n            m = \"{\" + m + \"}\";\n            break;\n\n          case \"|\":\n            if (0 === openenings.length) {\n              var altRegexGroup = groupify(currentToken.matches);\n              altRegexGroup.openGroup = !0, openenings.push(altRegexGroup), currentToken.matches = [], closeRegexGroup = !0;\n            }\n\n            break;\n        }\n        if (escaped) defaultCase();else switch (m.charAt(0)) {\n          case \"$\":\n          case \"^\":\n            regexMask || defaultCase();\n            break;\n\n          case \"(?=\":\n            break;\n\n          case \"(?!\":\n            break;\n\n          case \"(?<=\":\n            break;\n\n          case \"(?<!\":\n            break;\n\n          case opts.escapeChar:\n            escaped = !0, regexMask && defaultCase();\n            break;\n\n          case opts.optionalmarker[1]:\n          case opts.groupmarker[1]:\n            closeGroup();\n            break;\n\n          case opts.optionalmarker[0]:\n            openenings.push(new MaskToken(!1, !0));\n            break;\n\n          case opts.groupmarker[0]:\n            openenings.push(new MaskToken(!0));\n            break;\n\n          case opts.quantifiermarker[0]:\n            var quantifier = new MaskToken(!1, !1, !0);\n            m = m.replace(/[{}]/g, \"\");\n            var mqj = m.split(\"|\"),\n                mq = mqj[0].split(\",\"),\n                mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\n                mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);\n            \"*\" !== mq0 && \"+\" !== mq0 || (mq0 = \"*\" === mq1 ? 0 : 1), quantifier.quantifier = {\n              min: mq0,\n              max: mq1,\n              jit: mqj[1]\n            };\n            var matches = 0 < openenings.length ? openenings[openenings.length - 1].matches : currentToken.matches;\n\n            if (match = matches.pop(), match.isAlternator) {\n              matches.push(match), matches = match.matches;\n              var groupToken = new MaskToken(!0),\n                  tmpMatch = matches.pop();\n              matches.push(groupToken), matches = groupToken.matches, match = tmpMatch;\n            }\n\n            match.isGroup || (match = groupify([match])), matches.push(match), matches.push(quantifier);\n            break;\n\n          case opts.alternatormarker:\n            if (0 < openenings.length) {\n              currentOpeningToken = openenings[openenings.length - 1];\n              var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\n              lastMatch = currentOpeningToken.openGroup && (void 0 === subToken.matches || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : groupQuantifier(currentOpeningToken.matches);\n            } else lastMatch = groupQuantifier(currentToken.matches);\n\n            if (lastMatch.isAlternator) openenings.push(lastMatch);else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(), lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch), openenings.push(alternator), lastMatch.openGroup) {\n              lastMatch.openGroup = !1;\n              var alternatorGroup = new MaskToken(!0);\n              alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup);\n            }\n            break;\n\n          default:\n            defaultCase();\n        }\n      }\n\n      for (closeRegexGroup && closeGroup(); 0 < openenings.length;) {\n        openingToken = openenings.pop(), currentToken.matches.push(openingToken);\n      }\n\n      return 0 < currentToken.matches.length && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)), (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens;\n    }\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = void 0;\n    var _default = {\n      9: {\n        validator: \"[0-9\\uFF10-\\uFF19]\",\n        definitionSymbol: \"*\"\n      },\n      a: {\n        validator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\xC0-\\xFF\\xB5]\",\n        definitionSymbol: \"*\"\n      },\n      \"*\": {\n        validator: \"[0-9\\uFF10-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\xC0-\\xFF\\xB5]\"\n      }\n    };\n    exports[\"default\"] = _default;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    }), exports[\"default\"] = void 0;\n    var _default = {\n      _maxTestPos: 500,\n      placeholder: \"_\",\n      optionalmarker: [\"[\", \"]\"],\n      quantifiermarker: [\"{\", \"}\"],\n      groupmarker: [\"(\", \")\"],\n      alternatormarker: \"|\",\n      escapeChar: \"\\\\\",\n      mask: null,\n      regex: null,\n      oncomplete: function oncomplete() {},\n      onincomplete: function onincomplete() {},\n      oncleared: function oncleared() {},\n      repeat: 0,\n      greedy: !1,\n      autoUnmask: !1,\n      removeMaskOnSubmit: !1,\n      clearMaskOnLostFocus: !0,\n      insertMode: !0,\n      insertModeVisual: !0,\n      clearIncomplete: !1,\n      alias: null,\n      onKeyDown: function onKeyDown() {},\n      onBeforeMask: null,\n      onBeforePaste: function onBeforePaste(pastedValue, opts) {\n        return \"function\" == typeof opts.onBeforeMask ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\n      },\n      onBeforeWrite: null,\n      onUnMask: null,\n      showMaskOnFocus: !0,\n      showMaskOnHover: !0,\n      onKeyValidation: function onKeyValidation() {},\n      skipOptionalPartCharacter: \" \",\n      numericInput: !1,\n      rightAlign: !1,\n      undoOnEscape: !0,\n      radixPoint: \"\",\n      _radixDance: !1,\n      groupSeparator: \"\",\n      keepStatic: null,\n      positionCaretOnTab: !0,\n      tabThrough: !1,\n      supportsInputType: [\"text\", \"tel\", \"url\", \"password\", \"search\"],\n      ignorables: [8, 9, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],\n      isComplete: null,\n      preValidation: null,\n      postValidation: null,\n      staticDefinitionSymbol: void 0,\n      jitMasking: !1,\n      nullable: !0,\n      inputEventOnly: !1,\n      noValuePatching: !1,\n      positionCaretOnClick: \"lvp\",\n      casing: null,\n      inputmode: \"text\",\n      importDataAttributes: !0,\n      shiftPositions: !0,\n      usePrototypeDefinitions: !0\n    };\n    exports[\"default\"] = _default;\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var _inputmask = _interopRequireDefault(__webpack_require__(1)),\n        _keycode = _interopRequireDefault(__webpack_require__(0)),\n        _escapeRegex = _interopRequireDefault(__webpack_require__(14));\n\n    function _typeof(obj) {\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == _typeof2(Symbol.iterator) ? function _typeof(obj) {\n        return _typeof2(obj);\n      } : function _typeof(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      }, _typeof(obj);\n    }\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var $ = _inputmask[\"default\"].dependencyLib,\n        currentYear = new Date().getFullYear(),\n        formatCode = {\n      d: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate],\n      dd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () {\n        return pad(Date.prototype.getDate.call(this), 2);\n      }],\n      ddd: [\"\"],\n      dddd: [\"\"],\n      m: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\n        return Date.prototype.getMonth.call(this) + 1;\n      }],\n      mm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\n        return pad(Date.prototype.getMonth.call(this) + 1, 2);\n      }],\n      mmm: [\"\"],\n      mmmm: [\"\"],\n      yy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () {\n        return pad(Date.prototype.getFullYear.call(this), 2);\n      }],\n      yyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () {\n        return pad(Date.prototype.getFullYear.call(this), 4);\n      }],\n      h: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours],\n      hh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () {\n        return pad(Date.prototype.getHours.call(this), 2);\n      }],\n      hx: [function (x) {\n        return \"[0-9]{\".concat(x, \"}\");\n      }, Date.prototype.setHours, \"hours\", function (x) {\n        return Date.prototype.getHours;\n      }],\n      H: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours],\n      HH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () {\n        return pad(Date.prototype.getHours.call(this), 2);\n      }],\n      Hx: [function (x) {\n        return \"[0-9]{\".concat(x, \"}\");\n      }, Date.prototype.setHours, \"hours\", function (x) {\n        return function () {\n          return pad(Date.prototype.getHours.call(this), x);\n        };\n      }],\n      M: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes],\n      MM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () {\n        return pad(Date.prototype.getMinutes.call(this), 2);\n      }],\n      s: [\"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds],\n      ss: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function () {\n        return pad(Date.prototype.getSeconds.call(this), 2);\n      }],\n      l: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\n        return pad(Date.prototype.getMilliseconds.call(this), 3);\n      }],\n      L: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\n        return pad(Date.prototype.getMilliseconds.call(this), 2);\n      }],\n      t: [\"[ap]\"],\n      tt: [\"[ap]m\"],\n      T: [\"[AP]\"],\n      TT: [\"[AP]M\"],\n      Z: [\"\"],\n      o: [\"\"],\n      S: [\"\"]\n    },\n        formatAlias = {\n      isoDate: \"yyyy-mm-dd\",\n      isoTime: \"HH:MM:ss\",\n      isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\n      isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\"\n    };\n\n    function formatcode(match) {\n      var dynMatches = new RegExp(\"\\\\d+$\").exec(match[0]);\n\n      if (dynMatches && void 0 !== dynMatches[0]) {\n        var fcode = formatCode[match[0][0] + \"x\"].slice(\"\");\n        return fcode[0] = fcode[0](dynMatches[0]), fcode[3] = fcode[3](dynMatches[0]), fcode;\n      }\n\n      if (formatCode[match[0]]) return formatCode[match[0]];\n    }\n\n    function getTokenizer(opts) {\n      if (!opts.tokenizer) {\n        var tokens = [],\n            dyntokens = [];\n\n        for (var ndx in formatCode) {\n          if (/\\.*x$/.test(ndx)) {\n            var dynToken = ndx[0] + \"\\\\d+\";\n            -1 === dyntokens.indexOf(dynToken) && dyntokens.push(dynToken);\n          } else -1 === tokens.indexOf(ndx[0]) && tokens.push(ndx[0]);\n        }\n\n        opts.tokenizer = \"(\" + (0 < dyntokens.length ? dyntokens.join(\"|\") + \"|\" : \"\") + tokens.join(\"+|\") + \")+?|.\", opts.tokenizer = new RegExp(opts.tokenizer, \"g\");\n      }\n\n      return opts.tokenizer;\n    }\n\n    function prefillYear(dateParts, currentResult, opts) {\n      if (dateParts.year !== dateParts.rawyear) {\n        var crrntyear = currentYear.toString(),\n            enteredPart = dateParts.rawyear.replace(/[^0-9]/g, \"\"),\n            currentYearPart = crrntyear.slice(0, enteredPart.length),\n            currentYearNextPart = crrntyear.slice(enteredPart.length);\n\n        if (2 === enteredPart.length && enteredPart === currentYearPart) {\n          var entryCurrentYear = new Date(currentYear, dateParts.month - 1, dateParts.day);\n          dateParts.day == entryCurrentYear.getDate() && (!opts.max || opts.max.date.getTime() >= entryCurrentYear.getTime()) && (dateParts.date.setFullYear(currentYear), dateParts.year = crrntyear, currentResult.insert = [{\n            pos: currentResult.pos + 1,\n            c: currentYearNextPart[0]\n          }, {\n            pos: currentResult.pos + 2,\n            c: currentYearNextPart[1]\n          }]);\n        }\n      }\n\n      return currentResult;\n    }\n\n    function isValidDate(dateParts, currentResult, opts) {\n      if (!isFinite(dateParts.rawday) || \"29\" == dateParts.day && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day) return currentResult;\n\n      if (\"29\" == dateParts.day) {\n        var tokenMatch = getTokenMatch(currentResult.pos, opts);\n        if (\"yyyy\" === tokenMatch.targetMatch[0] && currentResult.pos - tokenMatch.targetMatchIndex == 2) return currentResult.remove = currentResult.pos + 1, currentResult;\n      }\n\n      return !1;\n    }\n\n    function isDateInRange(dateParts, result, opts, maskset, fromCheckval) {\n      if (!result) return result;\n\n      if (opts.min) {\n        if (dateParts.rawyear) {\n          var rawYear = dateParts.rawyear.replace(/[^0-9]/g, \"\"),\n              minYear = opts.min.year.substr(0, rawYear.length),\n              maxYear;\n\n          if (rawYear < minYear) {\n            var tokenMatch = getTokenMatch(result.pos, opts);\n            if (rawYear = dateParts.rawyear.substr(0, result.pos - tokenMatch.targetMatchIndex + 1), minYear = opts.min.year.substr(0, rawYear.length), minYear <= rawYear) return result.remove = tokenMatch.targetMatchIndex + rawYear.length, result;\n            if (rawYear = \"yyyy\" === tokenMatch.targetMatch[0] ? dateParts.rawyear.substr(1, 1) : dateParts.rawyear.substr(0, 1), minYear = opts.min.year.substr(2, 1), maxYear = opts.max ? opts.max.year.substr(2, 1) : rawYear, 1 === rawYear.length && minYear <= rawYear <= maxYear && !0 !== fromCheckval) return \"yyyy\" === tokenMatch.targetMatch[0] ? (result.insert = [{\n              pos: result.pos + 1,\n              c: rawYear,\n              strict: !0\n            }], result.caret = result.pos + 2, maskset.validPositions[result.pos].input = opts.min.year[1]) : (result.insert = [{\n              pos: result.pos + 1,\n              c: opts.min.year[1],\n              strict: !0\n            }, {\n              pos: result.pos + 2,\n              c: rawYear,\n              strict: !0\n            }], result.caret = result.pos + 3, maskset.validPositions[result.pos].input = opts.min.year[0]), result;\n            result = !1;\n          }\n        }\n\n        result && dateParts.year && dateParts.year === dateParts.rawyear && opts.min.date.getTime() == opts.min.date.getTime() && (result = opts.min.date.getTime() <= dateParts.date.getTime());\n      }\n\n      return result && opts.max && opts.max.date.getTime() == opts.max.date.getTime() && (result = opts.max.date.getTime() >= dateParts.date.getTime()), result;\n    }\n\n    function parse(format, dateObjValue, opts, raw) {\n      var mask = \"\",\n          match,\n          fcode;\n\n      for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);) {\n        if (void 0 === dateObjValue) {\n          if (fcode = formatcode(match)) mask += \"(\" + fcode[0] + \")\";else switch (match[0]) {\n            case \"[\":\n              mask += \"(\";\n              break;\n\n            case \"]\":\n              mask += \")?\";\n              break;\n\n            default:\n              mask += (0, _escapeRegex[\"default\"])(match[0]);\n          }\n        } else if (fcode = formatcode(match)) {\n          if (!0 !== raw && fcode[3]) {\n            var getFn = fcode[3];\n            mask += getFn.call(dateObjValue.date);\n          } else fcode[2] ? mask += dateObjValue[\"raw\" + fcode[2]] : mask += match[0];\n        } else mask += match[0];\n      }\n\n      return mask;\n    }\n\n    function pad(val, len) {\n      for (val = String(val), len = len || 2; val.length < len;) {\n        val = \"0\" + val;\n      }\n\n      return val;\n    }\n\n    function analyseMask(maskString, format, opts) {\n      var dateObj = {\n        date: new Date(1, 0, 1)\n      },\n          targetProp,\n          mask = maskString,\n          match,\n          dateOperation;\n\n      function setValue(dateObj, value, opts) {\n        dateObj[targetProp] = value.replace(/[^0-9]/g, \"0\"), dateObj[\"raw\" + targetProp] = value, void 0 !== dateOperation && dateOperation.call(dateObj.date, \"month\" == targetProp ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\n      }\n\n      if (\"string\" == typeof mask) {\n        for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(format);) {\n          var dynMatches = new RegExp(\"\\\\d+$\").exec(match[0]),\n              fcode = dynMatches ? match[0][0] + \"x\" : match[0],\n              value = void 0;\n\n          if (dynMatches) {\n            var lastIndex = getTokenizer(opts).lastIndex,\n                tokanMatch = getTokenMatch(match.index, opts);\n            getTokenizer(opts).lastIndex = lastIndex, value = mask.slice(0, mask.indexOf(tokanMatch.nextMatch[0]));\n          } else value = mask.slice(0, fcode.length);\n\n          Object.prototype.hasOwnProperty.call(formatCode, fcode) && (targetProp = formatCode[fcode][2], dateOperation = formatCode[fcode][1], setValue(dateObj, value, opts)), mask = mask.slice(value.length);\n        }\n\n        return dateObj;\n      }\n\n      if (mask && \"object\" === _typeof(mask) && Object.prototype.hasOwnProperty.call(mask, \"date\")) return mask;\n    }\n\n    function importDate(dateObj, opts) {\n      return parse(opts.inputFormat, {\n        date: dateObj\n      }, opts);\n    }\n\n    function getTokenMatch(pos, opts) {\n      var calcPos = 0,\n          targetMatch,\n          match,\n          matchLength = 0;\n\n      for (getTokenizer(opts).lastIndex = 0; match = getTokenizer(opts).exec(opts.inputFormat);) {\n        var dynMatches = new RegExp(\"\\\\d+$\").exec(match[0]);\n\n        if (matchLength = dynMatches ? parseInt(dynMatches[0]) : match[0].length, calcPos += matchLength, pos <= calcPos) {\n          targetMatch = match, match = getTokenizer(opts).exec(opts.inputFormat);\n          break;\n        }\n      }\n\n      return {\n        targetMatchIndex: calcPos - matchLength,\n        nextMatch: match,\n        targetMatch: targetMatch\n      };\n    }\n\n    _inputmask[\"default\"].extendAliases({\n      datetime: {\n        mask: function mask(opts) {\n          return opts.numericInput = !1, formatCode.S = opts.i18n.ordinalSuffix.join(\"|\"), opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat, opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat, opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat, opts.placeholder = \"\" !== opts.placeholder ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, \"\"), opts.regex = parse(opts.inputFormat, void 0, opts), opts.min = analyseMask(opts.min, opts.inputFormat, opts), opts.max = analyseMask(opts.max, opts.inputFormat, opts), null;\n        },\n        placeholder: \"\",\n        inputFormat: \"isoDateTime\",\n        displayFormat: void 0,\n        outputFormat: void 0,\n        min: null,\n        max: null,\n        skipOptionalPartCharacter: \"\",\n        i18n: {\n          dayNames: [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n          monthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n          ordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"]\n        },\n        preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {\n          if (strict) return !0;\n\n          if (isNaN(c) && buffer[pos] !== c) {\n            var tokenMatch = getTokenMatch(pos, opts);\n\n            if (tokenMatch.nextMatch && tokenMatch.nextMatch[0] === c && 1 < tokenMatch.targetMatch[0].length) {\n              var validator = formatCode[tokenMatch.targetMatch[0]][0];\n              if (new RegExp(validator).test(\"0\" + buffer[pos - 1])) return buffer[pos] = buffer[pos - 1], buffer[pos - 1] = \"0\", {\n                fuzzy: !0,\n                buffer: buffer,\n                refreshFromBuffer: {\n                  start: pos - 1,\n                  end: pos + 1\n                },\n                pos: pos + 1\n              };\n            }\n          }\n\n          return !0;\n        },\n        postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict, fromCheckval) {\n          if (strict) return !0;\n          var tokenMatch, validator;\n          if (!1 === currentResult) return tokenMatch = getTokenMatch(pos + 1, opts), tokenMatch.targetMatch && tokenMatch.targetMatchIndex === pos && 1 < tokenMatch.targetMatch[0].length && void 0 !== formatCode[tokenMatch.targetMatch[0]] && (validator = formatCode[tokenMatch.targetMatch[0]][0], new RegExp(validator).test(\"0\" + c)) ? {\n            insert: [{\n              pos: pos,\n              c: \"0\"\n            }, {\n              pos: pos + 1,\n              c: c\n            }],\n            pos: pos + 1\n          } : currentResult;\n\n          if (currentResult.fuzzy && (buffer = currentResult.buffer, pos = currentResult.pos), tokenMatch = getTokenMatch(pos, opts), tokenMatch.targetMatch && tokenMatch.targetMatch[0] && void 0 !== formatCode[tokenMatch.targetMatch[0]]) {\n            validator = formatCode[tokenMatch.targetMatch[0]][0];\n            var part = buffer.slice(tokenMatch.targetMatchIndex, tokenMatch.targetMatchIndex + tokenMatch.targetMatch[0].length);\n            !1 === new RegExp(validator).test(part.join(\"\")) && 2 === tokenMatch.targetMatch[0].length && maskset.validPositions[tokenMatch.targetMatchIndex] && maskset.validPositions[tokenMatch.targetMatchIndex + 1] && (maskset.validPositions[tokenMatch.targetMatchIndex + 1].input = \"0\");\n          }\n\n          var result = currentResult,\n              dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\n          return result && dateParts.date.getTime() == dateParts.date.getTime() && (result = prefillYear(dateParts, result, opts), result = isValidDate(dateParts, result, opts), result = isDateInRange(dateParts, result, opts, maskset, fromCheckval)), pos && result && currentResult.pos !== pos ? {\n            buffer: parse(opts.inputFormat, dateParts, opts).split(\"\"),\n            refreshFromBuffer: {\n              start: pos,\n              end: currentResult.pos\n            }\n          } : result;\n        },\n        onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {\n          var input = this;\n          e.ctrlKey && e.keyCode === _keycode[\"default\"].RIGHT && (this.inputmask._valueSet(importDate(new Date(), opts)), $(this).trigger(\"setvalue\"));\n        },\n        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n          return unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, !0) : unmaskedValue;\n        },\n        casing: function casing(elem, test, pos, validPositions) {\n          return 0 == test.nativeDef.indexOf(\"[ap]\") ? elem.toLowerCase() : 0 == test.nativeDef.indexOf(\"[AP]\") ? elem.toUpperCase() : elem;\n        },\n        onBeforeMask: function onBeforeMask(initialValue, opts) {\n          return \"[object Date]\" === Object.prototype.toString.call(initialValue) && (initialValue = importDate(initialValue, opts)), initialValue;\n        },\n        insertMode: !1,\n        shiftPositions: !1,\n        keepStatic: !1,\n        inputmode: \"numeric\"\n      }\n    });\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var _inputmask = _interopRequireDefault(__webpack_require__(1)),\n        _keycode = _interopRequireDefault(__webpack_require__(0)),\n        _escapeRegex = _interopRequireDefault(__webpack_require__(14));\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var $ = _inputmask[\"default\"].dependencyLib;\n\n    function autoEscape(txt, opts) {\n      for (var escapedTxt = \"\", i = 0; i < txt.length; i++) {\n        _inputmask[\"default\"].prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker[0] === txt.charAt(i) || opts.optionalmarker[1] === txt.charAt(i) || opts.quantifiermarker[0] === txt.charAt(i) || opts.quantifiermarker[1] === txt.charAt(i) || opts.groupmarker[0] === txt.charAt(i) || opts.groupmarker[1] === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += \"\\\\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);\n      }\n\n      return escapedTxt;\n    }\n\n    function alignDigits(buffer, digits, opts, force) {\n      if (0 < buffer.length && 0 < digits && (!opts.digitsOptional || force)) {\n        var radixPosition = buffer.indexOf(opts.radixPoint),\n            negationBack = !1;\n        opts.negationSymbol.back === buffer[buffer.length - 1] && (negationBack = !0, buffer.length--), -1 === radixPosition && (buffer.push(opts.radixPoint), radixPosition = buffer.length - 1);\n\n        for (var i = 1; i <= digits; i++) {\n          isFinite(buffer[radixPosition + i]) || (buffer[radixPosition + i] = \"0\");\n        }\n      }\n\n      return negationBack && buffer.push(opts.negationSymbol.back), buffer;\n    }\n\n    function findValidator(symbol, maskset) {\n      var posNdx = 0;\n\n      if (\"+\" === symbol) {\n        for (posNdx in maskset.validPositions) {\n          ;\n        }\n\n        posNdx = parseInt(posNdx);\n      }\n\n      for (var tstNdx in maskset.tests) {\n        if (tstNdx = parseInt(tstNdx), posNdx <= tstNdx) for (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) {\n          if ((void 0 === maskset.validPositions[tstNdx] || \"-\" === symbol) && maskset.tests[tstNdx][ndx].match.def === symbol) return tstNdx + (void 0 !== maskset.validPositions[tstNdx] && \"-\" !== symbol ? 1 : 0);\n        }\n      }\n\n      return posNdx;\n    }\n\n    function findValid(symbol, maskset) {\n      var ret = -1;\n\n      for (var ndx in maskset.validPositions) {\n        var tst = maskset.validPositions[ndx];\n\n        if (tst && tst.match.def === symbol) {\n          ret = parseInt(ndx);\n          break;\n        }\n      }\n\n      return ret;\n    }\n\n    function parseMinMaxOptions(opts) {\n      void 0 === opts.parseMinMaxOptions && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp((0, _escapeRegex[\"default\"])(opts.groupSeparator), \"g\"), \"\"), \",\" === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, \".\")), opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)), null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp((0, _escapeRegex[\"default\"])(opts.groupSeparator), \"g\"), \"\"), \",\" === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, \".\")), opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)), opts.parseMinMaxOptions = \"done\");\n    }\n\n    function genMask(opts) {\n      opts.repeat = 0, opts.groupSeparator === opts.radixPoint && opts.digits && \"0\" !== opts.digits && (\".\" === opts.radixPoint ? opts.groupSeparator = \",\" : \",\" === opts.radixPoint ? opts.groupSeparator = \".\" : opts.groupSeparator = \"\"), \" \" === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0), 1 < opts.placeholder.length && (opts.placeholder = opts.placeholder.charAt(0)), \"radixFocus\" === opts.positionCaretOnClick && \"\" === opts.placeholder && (opts.positionCaretOnClick = \"lvp\");\n      var decimalDef = \"0\",\n          radixPointDef = opts.radixPoint;\n      !0 === opts.numericInput && void 0 === opts.__financeInput ? (decimalDef = \"1\", opts.positionCaretOnClick = \"radixFocus\" === opts.positionCaretOnClick ? \"lvp\" : opts.positionCaretOnClick, opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts._radixDance = !1, radixPointDef = \",\" === opts.radixPoint ? \"?\" : \"!\", \"\" !== opts.radixPoint && void 0 === opts.definitions[radixPointDef] && (opts.definitions[radixPointDef] = {}, opts.definitions[radixPointDef].validator = \"[\" + opts.radixPoint + \"]\", opts.definitions[radixPointDef].placeholder = opts.radixPoint, opts.definitions[radixPointDef][\"static\"] = !0, opts.definitions[radixPointDef].generated = !0)) : (opts.__financeInput = !1, opts.numericInput = !0);\n      var mask = \"[+]\",\n          altMask;\n\n      if (mask += autoEscape(opts.prefix, opts), \"\" !== opts.groupSeparator ? (void 0 === opts.definitions[opts.groupSeparator] && (opts.definitions[opts.groupSeparator] = {}, opts.definitions[opts.groupSeparator].validator = \"[\" + opts.groupSeparator + \"]\", opts.definitions[opts.groupSeparator].placeholder = opts.groupSeparator, opts.definitions[opts.groupSeparator][\"static\"] = !0, opts.definitions[opts.groupSeparator].generated = !0), mask += opts._mask(opts)) : mask += \"9{+}\", void 0 !== opts.digits && 0 !== opts.digits) {\n        var dq = opts.digits.toString().split(\",\");\n        isFinite(dq[0]) && dq[1] && isFinite(dq[1]) ? mask += radixPointDef + decimalDef + \"{\" + opts.digits + \"}\" : (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && (opts.digitsOptional ? (altMask = mask + radixPointDef + decimalDef + \"{0,\" + opts.digits + \"}\", opts.keepStatic = !0) : mask += radixPointDef + decimalDef + \"{\" + opts.digits + \"}\");\n      }\n\n      return mask += autoEscape(opts.suffix, opts), mask += \"[-]\", altMask && (mask = [altMask + autoEscape(opts.suffix, opts) + \"[-]\", mask]), opts.greedy = !1, parseMinMaxOptions(opts), mask;\n    }\n\n    function hanndleRadixDance(pos, c, radixPos, maskset, opts) {\n      return opts._radixDance && opts.numericInput && c !== opts.negationSymbol.back && pos <= radixPos && (0 < radixPos || c == opts.radixPoint) && (void 0 === maskset.validPositions[pos - 1] || maskset.validPositions[pos - 1].input !== opts.negationSymbol.back) && (pos -= 1), pos;\n    }\n\n    function decimalValidator(chrs, maskset, pos, strict, opts) {\n      var radixPos = maskset.buffer ? maskset.buffer.indexOf(opts.radixPoint) : -1,\n          result = -1 !== radixPos && new RegExp(\"[0-9\\uFF11-\\uFF19]\").test(chrs);\n      return opts._radixDance && result && null == maskset.validPositions[radixPos] ? {\n        insert: {\n          pos: radixPos === pos ? radixPos + 1 : radixPos,\n          c: opts.radixPoint\n        },\n        pos: pos\n      } : result;\n    }\n\n    function checkForLeadingZeroes(buffer, opts) {\n      var numberMatches = new RegExp(\"(^\" + (\"\" !== opts.negationSymbol.front ? (0, _escapeRegex[\"default\"])(opts.negationSymbol.front) + \"?\" : \"\") + (0, _escapeRegex[\"default\"])(opts.prefix) + \")(.*)(\" + (0, _escapeRegex[\"default\"])(opts.suffix) + (\"\" != opts.negationSymbol.back ? (0, _escapeRegex[\"default\"])(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(buffer.slice().reverse().join(\"\")),\n          number = numberMatches ? numberMatches[2] : \"\",\n          leadingzeroes = !1;\n      return number && (number = number.split(opts.radixPoint.charAt(0))[0], leadingzeroes = new RegExp(\"^[0\" + opts.groupSeparator + \"]*\").exec(number)), !(!leadingzeroes || !(1 < leadingzeroes[0].length || 0 < leadingzeroes[0].length && leadingzeroes[0].length < number.length)) && leadingzeroes;\n    }\n\n    _inputmask[\"default\"].extendAliases({\n      numeric: {\n        mask: genMask,\n        _mask: function _mask(opts) {\n          return \"(\" + opts.groupSeparator + \"999){+|1}\";\n        },\n        digits: \"*\",\n        digitsOptional: !0,\n        enforceDigitsOnBlur: !1,\n        radixPoint: \".\",\n        positionCaretOnClick: \"radixFocus\",\n        _radixDance: !0,\n        groupSeparator: \"\",\n        allowMinus: !0,\n        negationSymbol: {\n          front: \"-\",\n          back: \"\"\n        },\n        prefix: \"\",\n        suffix: \"\",\n        min: null,\n        max: null,\n        SetMaxOnOverflow: !1,\n        step: 1,\n        inputType: \"text\",\n        unmaskAsNumber: !1,\n        roundingFN: Math.round,\n        inputmode: \"numeric\",\n        shortcuts: {\n          k: \"000\",\n          m: \"000000\"\n        },\n        placeholder: \"0\",\n        greedy: !1,\n        rightAlign: !0,\n        insertMode: !0,\n        autoUnmask: !1,\n        skipOptionalPartCharacter: \"\",\n        definitions: {\n          0: {\n            validator: decimalValidator\n          },\n          1: {\n            validator: decimalValidator,\n            definitionSymbol: \"9\"\n          },\n          \"+\": {\n            validator: function validator(chrs, maskset, pos, strict, opts) {\n              return opts.allowMinus && (\"-\" === chrs || chrs === opts.negationSymbol.front);\n            }\n          },\n          \"-\": {\n            validator: function validator(chrs, maskset, pos, strict, opts) {\n              return opts.allowMinus && chrs === opts.negationSymbol.back;\n            }\n          }\n        },\n        preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {\n          if (!1 !== opts.__financeInput && c === opts.radixPoint) return !1;\n          var pattern;\n\n          if (pattern = opts.shortcuts && opts.shortcuts[c]) {\n            if (1 < pattern.length) for (var inserts = [], i = 0; i < pattern.length; i++) {\n              inserts.push({\n                pos: pos + i,\n                c: pattern[i],\n                strict: !1\n              });\n            }\n            return {\n              insert: inserts\n            };\n          }\n\n          var radixPos = buffer.indexOf(opts.radixPoint),\n              initPos = pos;\n\n          if (pos = hanndleRadixDance(pos, c, radixPos, maskset, opts), \"-\" === c || c === opts.negationSymbol.front) {\n            if (!0 !== opts.allowMinus) return !1;\n            var isNegative = !1,\n                front = findValid(\"+\", maskset),\n                back = findValid(\"-\", maskset);\n            return -1 !== front && (isNegative = [front, back]), !1 !== isNegative ? {\n              remove: isNegative,\n              caret: initPos - opts.negationSymbol.front.length\n            } : {\n              insert: [{\n                pos: findValidator(\"+\", maskset),\n                c: opts.negationSymbol.front,\n                fromIsValid: !0\n              }, {\n                pos: findValidator(\"-\", maskset),\n                c: opts.negationSymbol.back,\n                fromIsValid: void 0\n              }],\n              caret: initPos + opts.negationSymbol.back.length\n            };\n          }\n\n          if (c === opts.groupSeparator) return {\n            caret: initPos\n          };\n          if (strict) return !0;\n          if (-1 !== radixPos && !0 === opts._radixDance && !1 === isSelection && c === opts.radixPoint && void 0 !== opts.digits && (isNaN(opts.digits) || 0 < parseInt(opts.digits)) && radixPos !== pos) return {\n            caret: opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos\n          };\n          if (!1 === opts.__financeInput) if (isSelection) {\n            if (opts.digitsOptional) return {\n              rewritePosition: caretPos.end\n            };\n\n            if (!opts.digitsOptional) {\n              if (caretPos.begin > radixPos && caretPos.end <= radixPos) return c === opts.radixPoint ? {\n                insert: {\n                  pos: radixPos + 1,\n                  c: \"0\",\n                  fromIsValid: !0\n                },\n                rewritePosition: radixPos\n              } : {\n                rewritePosition: radixPos + 1\n              };\n              if (caretPos.begin < radixPos) return {\n                rewritePosition: caretPos.begin - 1\n              };\n            }\n          } else if (!opts.showMaskOnHover && !opts.showMaskOnFocus && !opts.digitsOptional && 0 < opts.digits && \"\" === this.inputmask.__valueGet.call(this)) return {\n            rewritePosition: radixPos\n          };\n          return {\n            rewritePosition: pos\n          };\n        },\n        postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {\n          if (!1 === currentResult) return currentResult;\n          if (strict) return !0;\n\n          if (null !== opts.min || null !== opts.max) {\n            var unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), void 0, $.extend({}, opts, {\n              unmaskAsNumber: !0\n            }));\n            if (null !== opts.min && unmasked < opts.min && (unmasked.toString().length > opts.min.toString().length || unmasked < 0)) return !1;\n            if (null !== opts.max && unmasked > opts.max) return !!opts.SetMaxOnOverflow && {\n              refreshFromBuffer: !0,\n              buffer: alignDigits(opts.max.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\n            };\n          }\n\n          return currentResult;\n        },\n        onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n          if (\"\" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;\n          var processValue = maskedValue.replace(opts.prefix, \"\");\n          return processValue = processValue.replace(opts.suffix, \"\"), processValue = processValue.replace(new RegExp((0, _escapeRegex[\"default\"])(opts.groupSeparator), \"g\"), \"\"), \"\" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\")), opts.unmaskAsNumber ? (\"\" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(_escapeRegex[\"default\"].call(this, opts.radixPoint), \".\")), processValue = processValue.replace(new RegExp(\"^\" + (0, _escapeRegex[\"default\"])(opts.negationSymbol.front)), \"-\"), processValue = processValue.replace(new RegExp((0, _escapeRegex[\"default\"])(opts.negationSymbol.back) + \"$\"), \"\"), Number(processValue)) : processValue;\n        },\n        isComplete: function isComplete(buffer, opts) {\n          var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\n          return maskedValue = maskedValue.replace(new RegExp(\"^\" + (0, _escapeRegex[\"default\"])(opts.negationSymbol.front)), \"-\"), maskedValue = maskedValue.replace(new RegExp((0, _escapeRegex[\"default\"])(opts.negationSymbol.back) + \"$\"), \"\"), maskedValue = maskedValue.replace(opts.prefix, \"\"), maskedValue = maskedValue.replace(opts.suffix, \"\"), maskedValue = maskedValue.replace(new RegExp((0, _escapeRegex[\"default\"])(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\"), \",\" === opts.radixPoint && (maskedValue = maskedValue.replace((0, _escapeRegex[\"default\"])(opts.radixPoint), \".\")), isFinite(maskedValue);\n        },\n        onBeforeMask: function onBeforeMask(initialValue, opts) {\n          var radixPoint = opts.radixPoint || \",\";\n          isFinite(opts.digits) && (opts.digits = parseInt(opts.digits)), \"number\" != typeof initialValue && \"number\" !== opts.inputType || \"\" === radixPoint || (initialValue = initialValue.toString().replace(\".\", radixPoint));\n          var isNagtive = \"-\" === initialValue.charAt(0) || initialValue.charAt(0) === opts.negationSymbol.front,\n              valueParts = initialValue.split(radixPoint),\n              integerPart = valueParts[0].replace(/[^\\-0-9]/g, \"\"),\n              decimalPart = 1 < valueParts.length ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\",\n              forceDigits = 1 < valueParts.length;\n          initialValue = integerPart + (\"\" !== decimalPart ? radixPoint + decimalPart : decimalPart);\n          var digits = 0;\n\n          if (\"\" !== radixPoint && (digits = opts.digitsOptional ? opts.digits < decimalPart.length ? opts.digits : decimalPart.length : opts.digits, \"\" !== decimalPart || !opts.digitsOptional)) {\n            var digitsFactor = Math.pow(10, digits || 1);\n            initialValue = initialValue.replace((0, _escapeRegex[\"default\"])(radixPoint), \".\"), isNaN(parseFloat(initialValue)) || (initialValue = (opts.roundingFN(parseFloat(initialValue) * digitsFactor) / digitsFactor).toFixed(digits)), initialValue = initialValue.toString().replace(\".\", radixPoint);\n          }\n\n          if (0 === opts.digits && -1 !== initialValue.indexOf(radixPoint) && (initialValue = initialValue.substring(0, initialValue.indexOf(radixPoint))), null !== opts.min || null !== opts.max) {\n            var numberValue = initialValue.toString().replace(radixPoint, \".\");\n            null !== opts.min && numberValue < opts.min ? initialValue = opts.min.toString().replace(\".\", radixPoint) : null !== opts.max && numberValue > opts.max && (initialValue = opts.max.toString().replace(\".\", radixPoint));\n          }\n\n          return isNagtive && \"-\" !== initialValue.charAt(0) && (initialValue = \"-\" + initialValue), alignDigits(initialValue.toString().split(\"\"), digits, opts, forceDigits).join(\"\");\n        },\n        onBeforeWrite: function onBeforeWrite(e, buffer, caretPos, opts) {\n          function stripBuffer(buffer, stripRadix) {\n            if (!1 !== opts.__financeInput || stripRadix) {\n              var position = buffer.indexOf(opts.radixPoint);\n              -1 !== position && buffer.splice(position, 1);\n            }\n\n            if (\"\" !== opts.groupSeparator) for (; -1 !== (position = buffer.indexOf(opts.groupSeparator));) {\n              buffer.splice(position, 1);\n            }\n            return buffer;\n          }\n\n          var result,\n              leadingzeroes = checkForLeadingZeroes(buffer, opts);\n          if (leadingzeroes) for (var caretNdx = buffer.join(\"\").lastIndexOf(leadingzeroes[0].split(\"\").reverse().join(\"\")) - (leadingzeroes[0] == leadingzeroes.input ? 0 : 1), offset = leadingzeroes[0] == leadingzeroes.input ? 1 : 0, i = leadingzeroes[0].length - offset; 0 < i; i--) {\n            delete this.maskset.validPositions[caretNdx + i], delete buffer[caretNdx + i];\n          }\n          if (e) switch (e.type) {\n            case \"blur\":\n            case \"checkval\":\n              if (null !== opts.min) {\n                var unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), void 0, $.extend({}, opts, {\n                  unmaskAsNumber: !0\n                }));\n                if (null !== opts.min && unmasked < opts.min) return {\n                  refreshFromBuffer: !0,\n                  buffer: alignDigits(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\n                };\n              }\n\n              if (buffer[buffer.length - 1] === opts.negationSymbol.front) {\n                var nmbrMtchs = new RegExp(\"(^\" + (\"\" != opts.negationSymbol.front ? (0, _escapeRegex[\"default\"])(opts.negationSymbol.front) + \"?\" : \"\") + (0, _escapeRegex[\"default\"])(opts.prefix) + \")(.*)(\" + (0, _escapeRegex[\"default\"])(opts.suffix) + (\"\" != opts.negationSymbol.back ? (0, _escapeRegex[\"default\"])(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(stripBuffer(buffer.slice(), !0).reverse().join(\"\")),\n                    number = nmbrMtchs ? nmbrMtchs[2] : \"\";\n                0 == number && (result = {\n                  refreshFromBuffer: !0,\n                  buffer: [0]\n                });\n              } else \"\" !== opts.radixPoint && buffer[0] === opts.radixPoint && (result && result.buffer ? result.buffer.shift() : (buffer.shift(), result = {\n                refreshFromBuffer: !0,\n                buffer: stripBuffer(buffer)\n              }));\n\n              if (opts.enforceDigitsOnBlur) {\n                result = result || {};\n                var bffr = result && result.buffer || buffer.slice().reverse();\n                result.refreshFromBuffer = !0, result.buffer = alignDigits(bffr, opts.digits, opts, !0).reverse();\n              }\n\n          }\n          return result;\n        },\n        onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {\n          var $input = $(this),\n              bffr;\n          if (e.ctrlKey) switch (e.keyCode) {\n            case _keycode[\"default\"].UP:\n              return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger(\"setvalue\"), !1;\n\n            case _keycode[\"default\"].DOWN:\n              return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger(\"setvalue\"), !1;\n          }\n\n          if (!e.shiftKey && (e.keyCode === _keycode[\"default\"].DELETE || e.keyCode === _keycode[\"default\"].BACKSPACE || e.keyCode === _keycode[\"default\"].BACKSPACE_SAFARI) && caretPos.begin !== buffer.length) {\n            if (buffer[e.keyCode === _keycode[\"default\"].DELETE ? caretPos.begin - 1 : caretPos.end] === opts.negationSymbol.front) return bffr = buffer.slice().reverse(), \"\" !== opts.negationSymbol.front && bffr.shift(), \"\" !== opts.negationSymbol.back && bffr.pop(), $input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin]), !1;\n\n            if (!0 === opts._radixDance) {\n              var radixPos = buffer.indexOf(opts.radixPoint);\n\n              if (opts.digitsOptional) {\n                if (0 === radixPos) return bffr = buffer.slice().reverse(), bffr.pop(), $input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin >= bffr.length ? bffr.length : caretPos.begin]), !1;\n              } else if (-1 !== radixPos && (caretPos.begin < radixPos || caretPos.end < radixPos || e.keyCode === _keycode[\"default\"].DELETE && caretPos.begin === radixPos)) return caretPos.begin !== caretPos.end || e.keyCode !== _keycode[\"default\"].BACKSPACE && e.keyCode !== _keycode[\"default\"].BACKSPACE_SAFARI || caretPos.begin++, bffr = buffer.slice().reverse(), bffr.splice(bffr.length - caretPos.begin, caretPos.begin - caretPos.end + 1), bffr = alignDigits(bffr, opts.digits, opts).join(\"\"), $input.trigger(\"setvalue\", [bffr, caretPos.begin >= bffr.length ? radixPos + 1 : caretPos.begin]), !1;\n            }\n          }\n        }\n      },\n      currency: {\n        prefix: \"\",\n        groupSeparator: \",\",\n        alias: \"numeric\",\n        digits: 2,\n        digitsOptional: !1\n      },\n      decimal: {\n        alias: \"numeric\"\n      },\n      integer: {\n        alias: \"numeric\",\n        digits: 0\n      },\n      percentage: {\n        alias: \"numeric\",\n        min: 0,\n        max: 100,\n        suffix: \" %\",\n        digits: 0,\n        allowMinus: !1\n      },\n      indianns: {\n        alias: \"numeric\",\n        _mask: function _mask(opts) {\n          return \"(\" + opts.groupSeparator + \"99){*|1}(\" + opts.groupSeparator + \"999){1|1}\";\n        },\n        groupSeparator: \",\",\n        radixPoint: \".\",\n        placeholder: \"0\",\n        digits: 2,\n        digitsOptional: !1\n      }\n    });\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    var _window = _interopRequireDefault(__webpack_require__(6)),\n        _inputmask = _interopRequireDefault(__webpack_require__(1));\n\n    function _typeof(obj) {\n      return _typeof = \"function\" == typeof Symbol && \"symbol\" == _typeof2(Symbol.iterator) ? function _typeof(obj) {\n        return _typeof2(obj);\n      } : function _typeof(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      }, _typeof(obj);\n    }\n\n    function _classCallCheck(instance, Constructor) {\n      if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function _inherits(subClass, superClass) {\n      if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\");\n      subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n          value: subClass,\n          writable: !0,\n          configurable: !0\n        }\n      }), superClass && _setPrototypeOf(subClass, superClass);\n    }\n\n    function _createSuper(Derived) {\n      var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n      return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived),\n            result;\n\n        if (hasNativeReflectConstruct) {\n          var NewTarget = _getPrototypeOf(this).constructor;\n\n          result = Reflect.construct(Super, arguments, NewTarget);\n        } else result = Super.apply(this, arguments);\n\n        return _possibleConstructorReturn(this, result);\n      };\n    }\n\n    function _possibleConstructorReturn(self, call) {\n      return !call || \"object\" !== _typeof(call) && \"function\" != typeof call ? _assertThisInitialized(self) : call;\n    }\n\n    function _assertThisInitialized(self) {\n      if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return self;\n    }\n\n    function _wrapNativeSuper(Class) {\n      var _cache = \"function\" == typeof Map ? new Map() : void 0;\n\n      return _wrapNativeSuper = function _wrapNativeSuper(Class) {\n        if (null === Class || !_isNativeFunction(Class)) return Class;\n        if (\"function\" != typeof Class) throw new TypeError(\"Super expression must either be null or a function\");\n\n        if (\"undefined\" != typeof _cache) {\n          if (_cache.has(Class)) return _cache.get(Class);\n\n          _cache.set(Class, Wrapper);\n        }\n\n        function Wrapper() {\n          return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n        }\n\n        return Wrapper.prototype = Object.create(Class.prototype, {\n          constructor: {\n            value: Wrapper,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), _setPrototypeOf(Wrapper, Class);\n      }, _wrapNativeSuper(Class);\n    }\n\n    function _construct(Parent, args, Class) {\n      return _construct = _isNativeReflectConstruct() ? Reflect.construct : function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a),\n            instance = new Constructor();\n        return Class && _setPrototypeOf(instance, Class.prototype), instance;\n      }, _construct.apply(null, arguments);\n    }\n\n    function _isNativeReflectConstruct() {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (e) {\n        return !1;\n      }\n    }\n\n    function _isNativeFunction(fn) {\n      return -1 !== Function.toString.call(fn).indexOf(\"[native code]\");\n    }\n\n    function _setPrototypeOf(o, p) {\n      return _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        return o.__proto__ = p, o;\n      }, _setPrototypeOf(o, p);\n    }\n\n    function _getPrototypeOf(o) {\n      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      }, _getPrototypeOf(o);\n    }\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        \"default\": obj\n      };\n    }\n\n    var document = _window[\"default\"].document;\n\n    if (document && document.head && document.head.attachShadow && _window[\"default\"].customElements && void 0 === _window[\"default\"].customElements.get(\"input-mask\")) {\n      var InputmaskElement = function (_HTMLElement) {\n        _inherits(InputmaskElement, _HTMLElement);\n\n        var _super = _createSuper(InputmaskElement);\n\n        function InputmaskElement() {\n          var _this;\n\n          _classCallCheck(this, InputmaskElement), _this = _super.call(this);\n\n          var attributeNames = _this.getAttributeNames(),\n              shadow = _this.attachShadow({\n            mode: \"closed\"\n          }),\n              input = document.createElement(\"input\");\n\n          for (var attr in input.type = \"text\", shadow.appendChild(input), attributeNames) {\n            Object.prototype.hasOwnProperty.call(attributeNames, attr) && input.setAttribute(attributeNames[attr], _this.getAttribute(attributeNames[attr]));\n          }\n\n          var im = new _inputmask[\"default\"]();\n          return im.dataAttribute = \"\", im.mask(input), input.inputmask.shadowRoot = shadow, _this;\n        }\n\n        return InputmaskElement;\n      }(_wrapNativeSuper(HTMLElement));\n\n      _window[\"default\"].customElements.define(\"input-mask\", InputmaskElement);\n    }\n  }], installedModules = {}, __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {\n    __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {\n      enumerable: !0,\n      get: getter\n    });\n  }, __webpack_require__.r = function (exports) {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(exports, \"__esModule\", {\n      value: !0\n    });\n  }, __webpack_require__.t = function (value, mode) {\n    if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;\n    if (4 & mode && \"object\" == _typeof2(value) && value && value.__esModule) return value;\n    var ns = Object.create(null);\n    if (__webpack_require__.r(ns), Object.defineProperty(ns, \"default\", {\n      enumerable: !0,\n      value: value\n    }), 2 & mode && \"string\" != typeof value) for (var key in value) {\n      __webpack_require__.d(ns, key, function (key) {\n        return value[key];\n      }.bind(null, key));\n    }\n    return ns;\n  }, __webpack_require__.n = function (module) {\n    var getter = module && module.__esModule ? function getDefault() {\n      return module[\"default\"];\n    } : function getModuleExports() {\n      return module;\n    };\n    return __webpack_require__.d(getter, \"a\", getter), getter;\n  }, __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  }, __webpack_require__.p = \"\", __webpack_require__(__webpack_require__.s = 15);\n\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) return installedModules[moduleId].exports;\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: !1,\n      exports: {}\n    };\n    return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports;\n  }\n\n  var modules, installedModules;\n});","map":null,"metadata":{},"sourceType":"module"}